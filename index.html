<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX Трекер</title>
    <link rel="icon" href="data:,">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Base Layout */
        .app-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        
        #map {
            position: absolute;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: calc(100vh - 50px);
            transition: left 0.3s ease;
        }
        
        .app-container.drawer-open #map {
            left: 320px;
        }
        
        @media (max-width: 768px) {
            .app-container.drawer-open #map {
                left: 0;
            }
        }
        
        /* Top Bar */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: white;
            border-bottom: 1px solid #ddd;
            z-index: 1000;
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .btn-danger:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .btn-icon {
            background: transparent;
            border: 1px solid #ddd;
            padding: 6px 10px;
            font-size: 14px;
        }
        
        .btn-icon:hover {
            background: #f8f9fa;
        }
        
        .layer-select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            background: white;
            cursor: pointer;
        }
        
        .track-counter {
            font-size: 12px;
            color: #666;
            padding: 0 8px;
        }
        
        /* Editing Banner */
        .editing-banner {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            height: 40px;
            background: #ffc107;
            color: #000;
            z-index: 999;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .editing-banner.show {
            display: flex;
        }
        
        .editing-banner-text {
            font-weight: 500;
        }
        
        .editing-banner-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .editing-banner-btn {
            background: rgba(0,0,0,0.1);
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #000;
            transition: background 0.2s;
        }
        
        .editing-banner-btn:hover {
            background: rgba(0,0,0,0.2);
        }
        
        .editing-banner-close {
            background: rgba(0,0,0,0.1);
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .editing-banner-close:hover {
            background: rgba(0,0,0,0.2);
        }
        
        /* Drawer */
        .drawer {
            position: fixed;
            top: 50px;
            left: 0;
            width: 320px;
            height: calc(100vh - 50px);
            background: white;
            border-right: 1px solid #ddd;
            z-index: 900;
            display: flex;
            flex-direction: column;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
        }
        
        .drawer.open {
            transform: translateX(0);
        }
        
        .drawer-header {
            padding: 15px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .drawer-title {
            font-size: 16px;
            font-weight: 600;
        }
        
        .drawer-close {
            background: transparent;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .drawer-close:hover {
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .drawer-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        /* Tracks List */
        .tracks-list {
            list-style: none;
        }
        
        .track-item {
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .track-item:hover {
            background: #f8f9fa;
            border-color: #ddd;
        }
        
        .track-item.selected {
            background: #e3f2fd;
            border-color: #007bff;
        }
        
        .track-item.editing {
            background: #fff3cd;
            border-color: #ffc107;
        }
        
        .track-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .track-color-swatch {
            width: 20px;
            height: 3px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        .track-name {
            flex: 1;
            font-weight: 500;
            font-size: 14px;
        }
        
        .track-visibility-toggle {
            cursor: pointer;
            padding: 4px;
        }
        
        .track-actions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        
        .track-action-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            background: #f8f9fa;
            color: #333;
            transition: background 0.2s;
        }
        
        .track-action-btn:hover {
            background: #e9ecef;
        }
        
        .track-action-btn.more-btn {
            background: transparent;
            font-size: 16px;
            padding: 0 4px;
        }
        
        /* Track Details */
        .track-details {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            display: none;
        }
        
        .track-details.show {
            display: block;
        }
        
        .track-details-name {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            padding: 6px;
            border: 1px solid transparent;
            border-radius: 4px;
            cursor: text;
        }
        
        .track-details-name:focus {
            outline: none;
            border-color: #007bff;
            background: white;
        }
        
        .track-details-stats {
            font-size: 12px;
            color: #666;
            margin-bottom: 15px;
        }
        
        .track-details-stats-item {
            margin-bottom: 4px;
        }
        
        .track-details-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .track-details-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            text-align: left;
            transition: background 0.2s;
        }
        
        .track-details-btn.btn-focus {
            background: #007bff;
            color: white;
        }
        
        .track-details-btn.btn-focus:hover {
            background: #0056b3;
        }
        
        .track-details-btn.btn-start {
            background: #28a745;
            color: white;
        }
        
        .track-details-btn.btn-start:hover {
            background: #218838;
        }
        
        .track-details-btn.btn-end {
            background: #17a2b8;
            color: white;
        }
        
        .track-details-btn.btn-end:hover {
            background: #138496;
        }
        
        .track-details-btn.btn-edit {
            background: #ffc107;
            color: #000;
        }
        
        .track-details-btn.btn-edit:hover {
            background: #e0a800;
        }
        
        .track-details-btn.btn-export {
            background: #6c757d;
            color: white;
        }
        
        .track-details-btn.btn-export:hover {
            background: #5a6268;
        }
        
        .track-details-btn.btn-delete {
            background: #dc3545;
            color: white;
        }
        
        .track-details-btn.btn-delete:hover {
            background: #c82333;
        }
        
        /* More Menu */
        .more-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10000;
            min-width: 200px;
            display: none;
        }
        
        .more-menu.show {
            display: block;
        }
        
        .more-menu-section {
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }
        
        .more-menu-section:last-child {
            border-bottom: none;
        }
        
        .more-menu-section-title {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
        }
        
        .more-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
        }
        
        .more-menu-item:hover {
            background: #f0f0f0;
        }
        
        .more-menu-item.delete {
            color: #dc3545;
        }
        
        .more-menu-item.delete:hover {
            background: #f8d7da;
        }
        
        /* Context Menu (for editing markers) */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            padding: 4px 0;
            z-index: 10000;
            min-width: 150px;
            display: none;
        }
        
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
        }
        
        .context-menu-item:hover {
            background: #f0f0f0;
        }
        
        .context-menu-item.delete {
            color: #dc3545;
        }
        
        .context-menu-item.delete:hover {
            background: #f8d7da;
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .modal-overlay.show {
            display: flex;
        }
        
        .modal {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }
        
        .modal-content {
            font-size: 14px;
            line-height: 1.6;
            color: #666;
            margin-bottom: 20px;
        }
        
        .modal-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .modal-content li {
            margin: 8px 0;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .modal-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .modal-button.primary {
            background: #007bff;
            color: white;
        }
        
        .modal-button.primary:hover {
            background: #0056b3;
        }
        
        .modal-button.secondary {
            background: #6c757d;
            color: white;
        }
        
        .modal-button.secondary:hover {
            background: #5a6268;
        }
        
        .modal-checkbox {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #666;
        }

        .track-speed-tooltip {
            background: rgba(255,255,255,0.85);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 11px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .drawer {
                width: 100%;
                top: 0;
                height: 100vh;
                z-index: 2000;
            }
            
            .top-bar {
                z-index: 2001;
            }
            
            .editing-banner {
                top: 50px;
                z-index: 1999;
                height: auto;
                min-height: 40px;
                flex-wrap: wrap;
                padding: 8px 15px;
            }
            
            .editing-banner-text {
                width: 100%;
                margin-bottom: 8px;
            }
            
            .editing-banner-actions {
                width: 100%;
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .editing-banner-btn {
                font-size: 11px;
                padding: 4px 8px;
            }
            
            .editing-banner-close {
                font-size: 11px;
                padding: 4px 8px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="top-bar-left">
        <div class="file-input-wrapper">
                    <label for="gpx-file" class="btn btn-primary">Загрузить GPX</label>
            <input type="file" id="gpx-file" multiple accept=".gpx" />
        </div>
                <button class="btn btn-success" id="create-track-button">Создать трек</button>
                <button class="btn btn-danger" id="clear-button" disabled>Очистить</button>
                <select class="layer-select" id="layer-select">
                    <option value="none">Нет</option>
                    <option value="satellite">Спутник (Esri)</option>
                    <option value="carto">CartoDB Positron</option>
                    <option value="terrain">Рельеф (Stamen)</option>
                </select>
        </div>
            <div class="top-bar-right">
                <span class="track-counter" id="track-counter">Треков: 0</span>
                <button class="btn btn-icon" id="tracks-toggle">Треки</button>
            </div>
        </div>
        
        <!-- Editing Banner -->
        <div class="editing-banner" id="editing-banner">
            <span class="editing-banner-text" id="editing-banner-text">Редактирование: <span id="editing-track-name"></span></span>
            <div class="editing-banner-actions">
                <button class="editing-banner-btn" id="editing-banner-time">Установить время начала</button>
                <button class="editing-banner-btn" id="editing-banner-elevations">Установить высоту точек</button>
                <button class="editing-banner-btn" id="editing-banner-reverse">Реверс</button>
                <button class="editing-banner-close" id="editing-banner-close">Завершить редактирование</button>
            </div>
        </div>
        
        <!-- Drawer -->
        <div class="drawer" id="drawer">
            <div class="drawer-header">
                <div class="drawer-title">Треки</div>
                <button class="drawer-close" id="drawer-close">×</button>
            </div>
            <div class="drawer-content">
                <ul class="tracks-list" id="tracks-list"></ul>
                <div class="track-details" id="track-details">
                    <div class="track-details-name" id="track-details-name" contenteditable="true"></div>
                    <div class="track-details-stats" id="track-details-stats"></div>
                    <div class="track-details-actions">
                        <button class="track-details-btn btn-start" id="track-details-start">К началу</button>
                        <button class="track-details-btn btn-end" id="track-details-end">К концу</button>
                        <button class="track-details-btn btn-edit" id="track-details-edit">Редактировать</button>
                        <button class="track-details-btn btn-export" id="track-details-export">Экспорт</button>
                        <button class="track-details-btn btn-export" id="track-details-export-garmin">Garmin GPX</button>
                        <button class="track-details-btn btn-delete" id="track-details-delete">Удалить</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Map -->
        <div id="map"></div>
    </div>
    
    <!-- More Menu -->
    <div class="more-menu" id="more-menu">
        <div class="more-menu-section">
            <div class="more-menu-section-title">Общие</div>
            <div class="more-menu-item" id="more-edit">Редактировать</div>
            <div class="more-menu-item" id="more-start">К началу</div>
            <div class="more-menu-item" id="more-end">К концу</div>
        </div>
        <div class="more-menu-section">
            <div class="more-menu-section-title">Данные</div>
            <div class="more-menu-item" id="more-rename">Переименовать</div>
            <div class="more-menu-item" id="more-export">Экспорт</div>
            <div class="more-menu-item" id="more-export-garmin">Экспорт Garmin</div>
            <div class="more-menu-item" id="more-clone">Клонировать</div>
        </div>
        <div class="more-menu-section">
            <div class="more-menu-section-title">Продвинутые</div>
            <div class="more-menu-item" id="more-generate">Генерация трека</div>
            <div class="more-menu-item" id="more-segments">Удалить сегменты</div>
        </div>
        <div class="more-menu-section">
            <div class="more-menu-item delete" id="more-delete">Удалить</div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <!-- toGeoJSON -->
    <script src="https://unpkg.com/@mapbox/togeojson@0.16.2/togeojson.js"></script>
    
    <script>
        // Инициализация карты
        const map = L.map('map').setView([60.35, 29.73], 13);
        
        // Базовый слой OpenStreetMap (всегда активен)
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 25
        }).addTo(map);
        
        // Дополнительные слои (Wikimapia недоступна, используем альтернативы)
        // Спутниковые снимки Esri
        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; <a href="https://www.esri.com/">Esri</a>',
            maxZoom: 19,
            opacity: 0.7
        });
        
        // Легкая карта CartoDB Positron
        const cartoLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19,
            opacity: 0.7
        });
        
        // Рельефная карта Stamen Terrain
        const terrainLayer = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.png', {
            attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            subdomains: 'abcd',
            maxZoom: 18,
            opacity: 0.7
        });
        
        // Текущий активный дополнительный слой
        let currentOverlayLayer = null;
        
        // Хранение треков
        let tracks = [];
        let trackLayers = []; // Массив массивов слоев для каждого трека
        let trackStartMarkers = []; // Массивы маркеров начала трека
        let trackEndMarkers = []; // Массивы маркеров конца трека
        let trackVisibility = []; // Массив состояний видимости треков (true/false)
        let selectedTrackIndex = null;
        let editingTrackIndex = null; // Индекс трека в режиме редактирования
        let elevationRequestInFlight = false;
        const elevationCache = new Map();
        
        // Цвета для треков
        const colors = [
            '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF',
            '#00FFFF', '#FFA500', '#800080', '#FFC0CB', '#A52A2A'
        ];
        // Функция расчёта скорости между двумя точками в км/ч
        function calculateSpeed(coord1, coord2, time1, time2) {
            if (!time1 || !time2) return null;

            const distance = calculateDistance(coord1[1], coord1[0], coord2[1], coord2[0]); // в км
            const date1 = new Date(time1);
            const date2 = new Date(time2);

            if (isNaN(date1.getTime()) || isNaN(date2.getTime())) return null;

            const timeDiff = (date2 - date1) / 1000 / 3600; // в часах
            if (timeDiff <= 0) return null;

            return distance / timeDiff; // км/ч
        }

        // Функция определения стиля линии по скорости
        function getDashArrayBySpeed(speed) {
            if (speed === null || speed === undefined) {
                return null; // Сплошная линия, если нет данных о времени
            }
            if (speed < 6) return [3, 3];      // < 6 км/ч - пешеход (короткий пунктир)
            if (speed < 10) return [8, 4];     // 6-10 км/ч - лыжи (средний пунктир)
            return [12, 4];                     // > 10 км/ч - снегоход (длинный пунктир)
        }
        
        function getElevationCacheKey(coord) {
            return `${coord.latitude.toFixed(5)},${coord.longitude.toFixed(5)}`;
        }
        
        // Элементы DOM
        const fileInput = document.getElementById('gpx-file');
        const createTrackButton = document.getElementById('create-track-button');
        const clearButton = document.getElementById('clear-button');
        const layerSelect = document.getElementById('layer-select');
        const tracksToggle = document.getElementById('tracks-toggle');
        const drawer = document.getElementById('drawer');
        const drawerClose = document.getElementById('drawer-close');
        const editingBanner = document.getElementById('editing-banner');
        const editingBannerText = document.getElementById('editing-banner-text');
        const editingBannerClose = document.getElementById('editing-banner-close');
        const trackDetailsName = document.getElementById('track-details-name');
        const trackDetailsStart = document.getElementById('track-details-start');
        const trackDetailsEnd = document.getElementById('track-details-end');
        const trackDetailsEdit = document.getElementById('track-details-edit');
        const trackDetailsExport = document.getElementById('track-details-export');
        const trackDetailsExportGarmin = document.getElementById('track-details-export-garmin');
        const trackDetailsDelete = document.getElementById('track-details-delete');
        
        // Безопасное экранирование текста для вставки в HTML
        function escapeHtml(text) {
            if (text === null || text === undefined) {
                return '';
            }
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
        
        // Функция переключения дополнительного слоя
        function switchOverlayLayer(layerType) {
            // Удаляем текущий дополнительный слой
            if (currentOverlayLayer) {
                map.removeLayer(currentOverlayLayer);
                currentOverlayLayer = null;
            }
            
            // Добавляем новый слой
            switch(layerType) {
                case 'satellite':
                    currentOverlayLayer = satelliteLayer;
                    satelliteLayer.addTo(map);
                    break;
                case 'carto':
                    currentOverlayLayer = cartoLayer;
                    cartoLayer.addTo(map);
                    break;
                case 'terrain':
                    currentOverlayLayer = terrainLayer;
                    terrainLayer.addTo(map);
                    break;
                case 'none':
                default:
                    currentOverlayLayer = null;
                    break;
            }
        }
        
        // Обработчик переключения слоя
        layerSelect.addEventListener('change', function() {
            switchOverlayLayer(this.value);
        });
        
        // Обработчики drawer
        const appContainer = document.querySelector('.app-container');
        tracksToggle.addEventListener('click', function() {
            drawer.classList.toggle('open');
            if (appContainer) {
                appContainer.classList.toggle('drawer-open');
            }
        });
        
        drawerClose.addEventListener('click', function() {
            drawer.classList.remove('open');
            if (appContainer) {
                appContainer.classList.remove('drawer-open');
            }
        });
        
        // Обработчик баннера редактирования
        editingBannerClose.addEventListener('click', function() {
            if (editingTrackIndex !== null) {
                const trackIndex = editingTrackIndex;
                updateTrackGeoJSON(trackIndex);
                disableTrackEditing(trackIndex);
                updateTrackMarkers(trackIndex);
            }
        });
        
        // Обработчики кнопок баннера редактирования
        const editingBannerTime = document.getElementById('editing-banner-time');
        const editingBannerElevations = document.getElementById('editing-banner-elevations');
        
        editingBannerTime.addEventListener('click', function() {
            if (editingTrackIndex !== null) {
                const trackIndex = editingTrackIndex;
                // Функция setTrackStartTime сама сохранит изменения из маркеров редактирования
                setTrackStartTime(trackIndex);
            }
        });
        
        editingBannerElevations.addEventListener('click', function() {
            if (editingTrackIndex !== null) {
                const trackIndex = editingTrackIndex;
                // Функция setTrackElevations сама сохранит изменения из маркеров редактирования
                setTrackElevations(trackIndex);
            }
        });
        
        const editingBannerReverse = document.getElementById('editing-banner-reverse');
        editingBannerReverse.addEventListener('click', function() {
            if (editingTrackIndex !== null) {
                const trackIndex = editingTrackIndex;
                // Сохраняем изменения из маркеров редактирования перед реверсом
                updateTrackGeoJSON(trackIndex);
                // Отключаем редактирование перед реверсом
                disableTrackEditing(trackIndex);
                // Вызываем реверс
                reverseTrack(trackIndex);
                // Восстанавливаем режим редактирования после реверса
                // Используем небольшую задержку, чтобы дать время updateMap() завершиться
                setTimeout(() => {
                    if (trackIndex < tracks.length && trackIndex < trackLayers.length) {
                        enableTrackEditing(trackIndex);
                    }
                }, 100);
            }
        });
        
        // Обработчики деталей трека
        trackDetailsName.addEventListener('blur', function() {
            if (selectedTrackIndex !== null) {
                const newName = this.textContent.trim();
                if (newName && newName !== tracks[selectedTrackIndex].name) {
                    const existingIndex = tracks.findIndex((track, index) => 
                        index !== selectedTrackIndex && track.name === newName
                    );
                    if (existingIndex === -1) {
                        tracks[selectedTrackIndex].name = newName;
                        saveToSessionStorage();
                        updateTracksTable();
                    } else {
                        alert('Трек с таким именем уже существует');
                        this.textContent = tracks[selectedTrackIndex].name;
                    }
                } else if (!newName) {
                    this.textContent = tracks[selectedTrackIndex].name;
                }
            }
        });
        
        trackDetailsStart.addEventListener('click', function() {
            if (selectedTrackIndex !== null) {
                focusOnTrackStart(selectedTrackIndex);
            }
        });
        
        trackDetailsEnd.addEventListener('click', function() {
            if (selectedTrackIndex !== null) {
                focusOnTrackEnd(selectedTrackIndex);
            }
        });
        
        trackDetailsEdit.addEventListener('click', function() {
            if (selectedTrackIndex !== null) {
                const trackIndex = selectedTrackIndex;
                if (editingTrackIndex === trackIndex) {
                    updateTrackGeoJSON(trackIndex);
                    disableTrackEditing(trackIndex);
                    updateTrackMarkers(trackIndex);
                } else {
                    enableTrackEditing(trackIndex);
                }
            }
        });
        
        trackDetailsExport.addEventListener('click', function() {
            if (selectedTrackIndex !== null) {
                saveTrackToFile(selectedTrackIndex);
            }
        });
        
        trackDetailsExportGarmin.addEventListener('click', function() {
            if (selectedTrackIndex !== null) {
                saveTrackToGarminFile(selectedTrackIndex);
            }
        });
        
        trackDetailsDelete.addEventListener('click', function() {
            if (selectedTrackIndex !== null) {
                const trackIndex = selectedTrackIndex;
                if (editingTrackIndex !== null) {
                    if (!confirm('Вы редактируете трек. Удаление завершит редактирование. Продолжить?')) {
                        return;
                    }
                }
                if (confirm(`Удалить трек "${tracks[trackIndex].name}"?`)) {
                    deleteTrack(trackIndex);
                    selectedTrackIndex = null;
                    updateTracksTable();
                }
            }
        });
        
        // Обработчики меню More
        document.getElementById('more-edit').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                const trackIndex = currentMoreMenuTrackIndex;
                if (editingTrackIndex === trackIndex) {
                    updateTrackGeoJSON(trackIndex);
                    disableTrackEditing(trackIndex);
                    updateTrackMarkers(trackIndex);
                } else {
                    enableTrackEditing(trackIndex);
                }
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-start').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                focusOnTrackStart(currentMoreMenuTrackIndex);
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-end').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                focusOnTrackEnd(currentMoreMenuTrackIndex);
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-rename').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                renameTrack(currentMoreMenuTrackIndex);
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-export').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                saveTrackToFile(currentMoreMenuTrackIndex);
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-export-garmin').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                saveTrackToGarminFile(currentMoreMenuTrackIndex);
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-clone').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                cloneTrack(currentMoreMenuTrackIndex);
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-generate').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                generateTrackFromTrack(currentMoreMenuTrackIndex);
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-segments').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                mergeTrackSegments(currentMoreMenuTrackIndex);
                hideMoreMenu();
            }
        });
        
        document.getElementById('more-delete').addEventListener('click', function() {
            if (currentMoreMenuTrackIndex !== null) {
                const trackIndex = currentMoreMenuTrackIndex;
                if (editingTrackIndex !== null) {
                    if (!confirm('Вы редактируете трек. Удаление завершит редактирование. Продолжить?')) {
                        hideMoreMenu();
                        return;
                    }
                }
                if (confirm(`Удалить трек "${tracks[trackIndex].name}"?`)) {
                    deleteTrack(trackIndex);
                    if (selectedTrackIndex === trackIndex) {
                        selectedTrackIndex = null;
                    }
                    hideMoreMenu();
                }
            }
        });
        
        // Контекстное меню для строк таблицы
        let trackContextMenu = null;
        let currentTrackContextIndex = null;
        
        // Функция создания контекстного меню для трека
        function createTrackContextMenu() {
            if (trackContextMenu) {
                document.body.removeChild(trackContextMenu);
            }
            
            trackContextMenu = document.createElement('div');
            trackContextMenu.className = 'context-menu';
            trackContextMenu.id = 'track-context-menu';
            trackContextMenu.innerHTML = `
                <div class="context-menu-item" id="track-edit">Редактировать</div>
                <div class="context-menu-item" id="track-focus">На карте</div>
                <div class="context-menu-item" id="track-focus-start">К началу</div>
                <div class="context-menu-item" id="track-focus-end">К концу</div>
                <div class="context-menu-item" id="track-rename">Переименовать</div>
                <div class="context-menu-item" id="track-save">Сохранить</div>
                <div class="context-menu-item" id="track-save-garmin">Сохранить (Garmin)</div>
                <div class="context-menu-item" id="track-clone">Клонировать</div>
                <div class="context-menu-item" id="track-generate">Генерация трека</div>
                <div class="context-menu-item" id="track-reverse">Реверс</div>
                <div class="context-menu-item" id="track-set-start-time">Установить время начала</div>
                <div class="context-menu-item" id="track-set-elevations">Установить высоту точек</div>
                <div class="context-menu-item" id="track-merge-segments">Удалить сегменты</div>
                <div class="context-menu-item delete" id="track-delete">Удалить</div>
            `;
            document.body.appendChild(trackContextMenu);
            
            // Обработчики пунктов меню
            document.getElementById('track-edit').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    if (editingTrackIndex === trackIndex) {
                        // Сохраняем GeoJSON перед выходом из режима редактирования
                        updateTrackGeoJSON(trackIndex);
                        disableTrackEditing(trackIndex);
                        // Обновляем маркеры начала и конца после сохранения
                        updateTrackMarkers(trackIndex);
                    } else {
                        enableTrackEditing(trackIndex);
                    }
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-focus').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    const row = tableBody.querySelector(`tr[data-track-index="${trackIndex}"]`);
                    
                    const previousSelected = tableBody.querySelector('tr.selected');
                    if (previousSelected) {
                        previousSelected.classList.remove('selected');
                    }
                    
                    if (row) {
                        row.classList.add('selected');
                        selectedTrackIndex = trackIndex;
                    }
                    
                    focusOnTrack(trackIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-focus-start').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    focusOnTrackStart(trackIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-focus-end').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    focusOnTrackEnd(trackIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-rename').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    renameTrack(currentTrackContextIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-save').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    saveTrackToFile(currentTrackContextIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-save-garmin').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    saveTrackToGarminFile(currentTrackContextIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-clone').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    cloneTrack(currentTrackContextIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-generate').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    generateTrackFromTrack(trackIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-reverse').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    reverseTrack(trackIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-set-start-time').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    setTrackStartTime(trackIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-set-elevations').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    setTrackElevations(trackIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-merge-segments').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    mergeTrackSegments(trackIndex);
                    hideTrackContextMenu();
                }
            });
            
            document.getElementById('track-delete').addEventListener('click', function() {
                if (currentTrackContextIndex !== null) {
                    const trackIndex = currentTrackContextIndex;
                    if (confirm(`Удалить трек "${tracks[trackIndex].name}"?`)) {
                        deleteTrack(trackIndex);
                    }
                    hideTrackContextMenu();
                }
            });
        }
        
        // Функция показа контекстного меню для трека
        function showTrackContextMenu(event, trackIndex) {
            event.preventDefault();
            event.stopPropagation();
            currentTrackContextIndex = trackIndex;
            
            if (!trackContextMenu) {
                createTrackContextMenu();
            }
            
            // Обновляем текст кнопки редактирования
            const editItem = document.getElementById('track-edit');
            if (editingTrackIndex === trackIndex) {
                editItem.textContent = 'Сохранить';
            } else {
                editItem.textContent = 'Редактировать';
            }
            
            trackContextMenu.style.display = 'block';
            trackContextMenu.style.left = event.pageX + 'px';
            trackContextMenu.style.top = event.pageY + 'px';
            
            setTimeout(() => {
                document.addEventListener('click', hideTrackContextMenuOnClick, true);
            }, 0);
        }
        
        // Обработчик клика для скрытия контекстного меню трека
        function hideTrackContextMenuOnClick(event) {
            if (trackContextMenu && !trackContextMenu.contains(event.target)) {
                hideTrackContextMenu();
                document.removeEventListener('click', hideTrackContextMenuOnClick, true);
            }
        }
        
        // Функция скрытия контекстного меню трека
        function hideTrackContextMenu() {
            if (trackContextMenu) {
                trackContextMenu.style.display = 'none';
            }
            currentTrackContextIndex = null;
            document.removeEventListener('click', hideTrackContextMenuOnClick, true);
        }
        
        
        // Функция загрузки GPX файла
        function loadGPXFile(file) {
            return new Promise((resolve, reject) => {
                if (file.size > 10 * 1024 * 1024) {
                    reject(new Error(`Файл ${file.name} превышает 10 MB`));
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const gpxText = e.target.result;
                        const gpxDoc = new DOMParser().parseFromString(gpxText, 'text/xml');
                        
                        // Проверка на ошибки парсинга XML
                        const parserError = gpxDoc.querySelector('parsererror');
                        if (parserError) {
                            throw new Error('Ошибка парсинга XML');
                        }
                        
                        // Конвертация GPX в GeoJSON
                        if (typeof toGeoJSON === 'undefined' || typeof toGeoJSON.gpx !== 'function') {
                            throw new Error('Библиотека toGeoJSON не загружена. Проверьте подключение скрипта.');
                        }
                        const geoJson = toGeoJSON.gpx(gpxDoc);
                        
                        if (!geoJson || !geoJson.features || geoJson.features.length === 0) {
                            throw new Error('GPX файл не содержит треков');
                        }
                        
                        // Извлекаем высоту из координат и сохраняем в properties.elevations
                        geoJson.features.forEach(feature => {
                            if (feature.geometry && feature.geometry.type === 'LineString') {
                                const coordinates = feature.geometry.coordinates;
                                const elevations = [];
                                
                                coordinates.forEach(coord => {
                                    // Высота может быть в координатах как третье значение [lon, lat, ele]
                                    if (coord.length > 2 && coord[2] !== undefined && coord[2] !== null) {
                                        elevations.push(coord[2]);
                                    } else {
                                        elevations.push(null);
                                    }
                                });
                                
                                // Сохраняем высоту в properties
                                if (!feature.properties) {
                                    feature.properties = {};
                                }
                                feature.properties.elevations = elevations;
                            }
                        });
                        
                        resolve({
                            name: file.name,
                            geoJson: geoJson
                        });
                    } catch (error) {
                        reject(new Error(`Ошибка обработки ${file.name}: ${error.message}`));
                    }
                };
                
                reader.onerror = function() {
                    reject(new Error(`Ошибка чтения файла ${file.name}`));
                };
                
                reader.readAsText(file);
            });
        }
        
        // Функция отрисовки трека
        function renderTrack(trackData, color) {
            const features = trackData.geoJson.features;
            const layers = [];
            const startMarkers = [];
            const endMarkers = [];
            const averageSpeed = calculateTrackAverageSpeed(trackData);
            let speedLabelAttached = false;

            // Если нет features или они пустые, создаем пустую полилинию
            if (features.length === 0 || (features.length === 1 && features[0].geometry.coordinates.length === 0)) {
                const polyline = L.polyline([], {
                    color: color,
                    weight: 3,
                    opacity: 0.8
                }).addTo(map);
                polyline.featureIndex = 0;
                layers.push(polyline);
                return { layers, startMarkers, endMarkers };
            }

            features.forEach((feature, featureIndex) => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coords = feature.geometry.coordinates;
                    const coordinates = coords.map(coord => [coord[1], coord[0]]);
                    const coordTimes = feature.properties && feature.properties.coordTimes ?
                        feature.properties.coordTimes : [];

                    // Если есть время, создаем отдельные полилинии для каждого сегмента с разной скоростью
                    if (coordTimes.length >= 2 && coordinates.length >= 2) {
                        let blockStart = 0;
                        let currentDashArray = null;

                        for (let i = 1; i < coordinates.length; i++) {
                            // Рассчитываем скорость для текущего сегмента
                            const speed = calculateSpeed(coords[i - 1], coords[i], coordTimes[i - 1], coordTimes[i]);
                            const dashArray = getDashArrayBySpeed(speed);

                            // Проверяем, изменился ли стиль линии
                            const dashChanged = JSON.stringify(dashArray) !== JSON.stringify(currentDashArray);

                            if (dashChanged && i > blockStart + 1) {
                                // Создаём полилинию для предыдущего блока
                                const segmentCoords = coordinates.slice(blockStart, i);
                                if (segmentCoords.length >= 2) {
                                    const segmentPolyline = L.polyline(segmentCoords, {
                                        color: color,
                                        weight: 3,
                                        opacity: 0.8,
                                        dashArray: currentDashArray
                                    }).addTo(map);
                                    segmentPolyline.featureIndex = featureIndex;
                                    segmentPolyline.startCoordIndex = blockStart;
                                    layers.push(segmentPolyline);
                                    
                                    if (averageSpeed !== null && !speedLabelAttached) {
                                        segmentPolyline.bindTooltip(`Ср. скорость: ${averageSpeed.toFixed(2)} км/ч`, {
                                            permanent: true,
                                            direction: 'center',
                                            className: 'track-speed-tooltip'
                                        });
                                        speedLabelAttached = true;
                                    }
                                }
                                blockStart = i - 1;
                            }

                            currentDashArray = dashArray;
                        }

                        // Добавляем последний блок
                        const finalCoords = coordinates.slice(blockStart);
                        if (finalCoords.length >= 2) {
                            const finalPolyline = L.polyline(finalCoords, {
                                color: color,
                                weight: 3,
                                opacity: 0.8,
                                dashArray: currentDashArray
                            }).addTo(map);
                            finalPolyline.featureIndex = featureIndex;
                            finalPolyline.startCoordIndex = blockStart;
                            layers.push(finalPolyline);
                            
                            if (averageSpeed !== null && !speedLabelAttached) {
                                finalPolyline.bindTooltip(`Ср. скорость: ${averageSpeed.toFixed(2)} км/ч`, {
                                    permanent: true,
                                    direction: 'center',
                                    className: 'track-speed-tooltip'
                                });
                                speedLabelAttached = true;
                            }
                        }
                    } else {
                        // Если нет времени - сплошная линия
                        const polyline = L.polyline(coordinates, {
                            color: color,
                            weight: 3,
                            opacity: 0.8
                        }).addTo(map);
                        polyline.featureIndex = featureIndex;
                        polyline.startCoordIndex = 0;
                        layers.push(polyline);
                        
                        if (averageSpeed !== null && !speedLabelAttached) {
                            polyline.bindTooltip(`Ср. скорость: ${averageSpeed.toFixed(2)} км/ч`, {
                                permanent: true,
                                direction: 'center',
                                className: 'track-speed-tooltip'
                            });
                            speedLabelAttached = true;
                        }
                    }

                    // Получаем высоту для точек этого сегмента
                    const elevations = feature.properties && feature.properties.elevations ?
                        feature.properties.elevations : [];

                    // Создаем маркер начала трека (зеленый) - только для первого сегмента
                    if (featureIndex === 0 && coordinates.length > 0) {
                        const startTime = coordTimes[0];
                        const startElevation = elevations[0];
                        const timeTooltip = formatDateTimeWithTZ(startTime);
                        
                        let tooltipText = 'Начало';
                        if (timeTooltip) {
                            tooltipText += ': ' + timeTooltip;
                        }
                        if (startElevation !== null && startElevation !== undefined) {
                            tooltipText += '\nВысота: ' + startElevation.toFixed(1) + ' м';
                        }
                        
                        const startMarker = L.marker(coordinates[0], {
                            icon: L.divIcon({
                                className: 'track-start-marker',
                                html: '<div style="background: #28a745; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>',
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        }).addTo(map);
                        
                        // Добавляем tooltip с временем и высотой
                        if (tooltipText !== 'Начало') {
                            startMarker.bindTooltip(tooltipText, {
                                permanent: false,
                                direction: 'top',
                                offset: [0, -10]
                            });
                        }
                        
                        startMarkers.push(startMarker);
                    }
                    
                    // Создаем маркер конца трека (красный) - только для последнего сегмента
                    if (featureIndex === features.length - 1 && coordinates.length > 0) {
                        const endTime = coordTimes[coordTimes.length - 1];
                        const endElevation = elevations[elevations.length - 1];
                        const timeTooltip = formatDateTimeWithTZ(endTime);
                        
                        let tooltipText = 'Конец';
                        if (timeTooltip) {
                            tooltipText += ': ' + timeTooltip;
                        }
                        if (endElevation !== null && endElevation !== undefined) {
                            tooltipText += '\nВысота: ' + endElevation.toFixed(1) + ' м';
                        }
                        
                        const endMarker = L.marker(coordinates[coordinates.length - 1], {
                            icon: L.divIcon({
                                className: 'track-end-marker',
                                html: '<div style="background: #dc3545; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>',
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        }).addTo(map);
                        
                        // Добавляем tooltip с временем и высотой
                        if (tooltipText !== 'Конец') {
                            endMarker.bindTooltip(tooltipText, {
                                permanent: false,
                                direction: 'top',
                                offset: [0, -10]
                            });
                        }
                        
                        endMarkers.push(endMarker);
                    }
                }
            });
            
            return { layers, startMarkers, endMarkers };
        }
        
        // Хранение маркеров редактирования
        let editMarkers = [];
        let editMarkerData = []; // Данные о маркерах: {layer, pointIndex, markerIndex, originalPointIndex, featureIndex, startCoordIndex}
        let contextMenu = null; // Контекстное меню
        let currentEditingMarker = null; // Текущий маркер для контекстного меню
        let mapClickHandler = null; // Обработчик клика на карту для рисования трека
        
        // Функция создания контекстного меню
        function createContextMenu() {
            if (contextMenu) {
                document.body.removeChild(contextMenu);
            }
            
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            contextMenu.innerHTML = `
                <div class="context-menu-item delete" id="delete-point">Удалить точку</div>
                <div class="context-menu-item delete" id="delete-points-after">Удалить все точки после</div>
                <div class="context-menu-item delete" id="delete-points-before">Удалить все точки перед</div>
                <div class="context-menu-item" id="set-segment-speed">Пересчитать время от этой точки</div>
            `;
            document.body.appendChild(contextMenu);
            
            // Обработчик удаления точки
            document.getElementById('delete-point').addEventListener('click', function() {
                if (currentEditingMarker !== null) {
                    deletePointFromTrack(currentEditingMarker);
                    hideContextMenu();
                }
            });
            
            // Обработчик удаления всех точек после
            document.getElementById('delete-points-after').addEventListener('click', function() {
                if (currentEditingMarker !== null) {
                    deletePointsAfter(currentEditingMarker);
                    hideContextMenu();
                }
            });
            
            // Обработчик удаления всех точек перед
            document.getElementById('delete-points-before').addEventListener('click', function() {
                if (currentEditingMarker !== null) {
                    deletePointsBefore(currentEditingMarker);
                    hideContextMenu();
                }
            });

            document.getElementById('set-segment-speed').addEventListener('click', function() {
                if (currentEditingMarker !== null) {
                    setSpeedFromPoint(currentEditingMarker);
                    hideContextMenu();
                }
            });
        }
        
        // Функция показа контекстного меню
        function showContextMenu(event, markerData) {
            event.preventDefault();
            event.stopPropagation();
            currentEditingMarker = markerData;
            
            if (!contextMenu) {
                createContextMenu();
            }
            
            contextMenu.style.display = 'block';
            contextMenu.style.left = event.pageX + 'px';
            contextMenu.style.top = event.pageY + 'px';
            
            // Добавляем обработчик клика вне меню для его скрытия
            setTimeout(() => {
                document.addEventListener('click', hideContextMenuOnClick, true);
            }, 0);
        }
        
        // Обработчик клика для скрытия контекстного меню
        function hideContextMenuOnClick(event) {
            if (contextMenu && !contextMenu.contains(event.target)) {
                hideContextMenu();
                document.removeEventListener('click', hideContextMenuOnClick, true);
            }
        }
        
        // Функция скрытия контекстного меню
        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            currentEditingMarker = null;
            document.removeEventListener('click', hideContextMenuOnClick, true);
        }
        
        // Функция синхронизации маркеров редактирования с полилинией
        function syncEditMarkersWithPolyline() {
            if (editingTrackIndex === null || editMarkers.length === 0) {
                return;
            }
            
            editMarkers.forEach((marker, markerIndex) => {
                const markerData = editMarkerData[markerIndex];
                if (!markerData || !markerData.layer) {
                    return;
                }
                
                const layer = markerData.layer;
                const originalPointIndex = markerData.originalPointIndex;
                const startOffset = markerData.startCoordIndex || 0;
                const localIndex = originalPointIndex - startOffset;
                if (localIndex < 0) {
                    return;
                }
                let latlngs = layer.getLatLngs();
                
                // Обрабатываем случай массива массивов
                let isMultiSegment = false;
                if (Array.isArray(latlngs[0]) && latlngs[0].length > 0 && typeof latlngs[0][0] === 'object' && 'lat' in latlngs[0][0]) {
                    isMultiSegment = true;
                }
                
                let targetLatLng = null;
                
                if (isMultiSegment) {
                    // Многосегментная полилиния
                    let currentIndex = 0;
                    for (let i = 0; i < latlngs.length; i++) {
                        if (currentIndex + latlngs[i].length > localIndex) {
                            const segmentPointIndex = localIndex - currentIndex;
                            if (latlngs[i][segmentPointIndex]) {
                                targetLatLng = latlngs[i][segmentPointIndex];
                            }
                            break;
                        }
                        currentIndex += latlngs[i].length;
                    }
                } else {
                    // Простая полилиния
                    if (latlngs[localIndex]) {
                        targetLatLng = latlngs[localIndex];
                    }
                }
                
                // Обновляем позицию маркера, если координаты изменились
                if (targetLatLng) {
                    const currentPos = marker.getLatLng();
                    if (Math.abs(currentPos.lat - targetLatLng.lat) > 0.000001 || 
                        Math.abs(currentPos.lng - targetLatLng.lng) > 0.000001) {
                        marker.setLatLng(targetLatLng);
                    }
                }
            });
        }
        
        // Функция удаления точки из трека
        function deletePointFromTrack(markerData) {
            const { layer, pointIndex, originalPointIndex, startCoordIndex = 0 } = markerData;
            const trackIndex = editingTrackIndex;
            
            if (trackIndex === null || !layer) {
                return;
            }
            
            let latlngs = layer.getLatLngs();
            const localIndex = originalPointIndex - startCoordIndex;
            if (localIndex < 0) {
                return;
            }
            
            // Обрабатываем случай массива массивов
            if (Array.isArray(latlngs[0]) && latlngs[0].length > 0 && typeof latlngs[0][0] === 'object' && 'lat' in latlngs[0][0]) {
                // Многосегментная полилиния
                let totalPoints = 0;
                latlngs.forEach(segment => totalPoints += segment.length);
                
                if (totalPoints <= 2) {
                    alert('Трек должен содержать минимум 2 точки');
                    return;
                }
                
                let currentIndex = 0;
                for (let i = 0; i < latlngs.length; i++) {
                    if (currentIndex + latlngs[i].length > localIndex) {
                        const segmentPointIndex = localIndex - currentIndex;
                        // Удаляем точку из сегмента
                        latlngs[i].splice(segmentPointIndex, 1);
                        // Если сегмент стал пустым или с одной точкой, удаляем его
                        if (latlngs[i].length < 2) {
                            latlngs.splice(i, 1);
                        }
                        break;
                    }
                    currentIndex += latlngs[i].length;
                }
            } else {
                // Простая полилиния - удаляем точку
                if (latlngs.length > 2 && localIndex < latlngs.length) {
                    latlngs.splice(localIndex, 1);
                } else {
                    // Нельзя удалить точку, если останется меньше 2 точек
                    alert('Трек должен содержать минимум 2 точки');
                    return;
                }
            }
            
            // Обновляем полилинию
            layer.setLatLngs(latlngs);
            
            // Пересоздаем маркеры редактирования
            disableTrackEditing(trackIndex);
            enableTrackEditing(trackIndex);
            
            // Обновляем GeoJSON
            updateTrackGeoJSON(trackIndex);
        }
        
        // Функция удаления всех точек после выбранной точки
        function deletePointsAfter(markerData) {
            const { layer, pointIndex, originalPointIndex, startCoordIndex = 0 } = markerData;
            const trackIndex = editingTrackIndex;
            
            if (trackIndex === null || !layer) {
                return;
            }
            
            let latlngs = layer.getLatLngs();
            let isMultiSegment = false;
            const localIndex = originalPointIndex - startCoordIndex;
            if (localIndex < 0) {
                return;
            }
            
            // Обрабатываем случай массива массивов
            if (Array.isArray(latlngs[0]) && latlngs[0].length > 0 && typeof latlngs[0][0] === 'object' && 'lat' in latlngs[0][0]) {
                isMultiSegment = true;
            }
            
            if (isMultiSegment) {
                // Многосегментная полилиния
                let currentIndex = 0;
                let targetSegmentIndex = -1;
                let targetPointIndex = -1;
                
                // Находим сегмент и точку
                for (let i = 0; i < latlngs.length; i++) {
                    if (currentIndex + latlngs[i].length > localIndex) {
                        targetSegmentIndex = i;
                        targetPointIndex = localIndex - currentIndex;
                        break;
                    }
                    currentIndex += latlngs[i].length;
                }
                
                if (targetSegmentIndex === -1) {
                    return;
                }
                
                // Подсчитываем общее количество точек после выбранной
                let pointsAfter = 0;
                for (let i = targetSegmentIndex; i < latlngs.length; i++) {
                    if (i === targetSegmentIndex) {
                        pointsAfter += latlngs[i].length - targetPointIndex - 1;
                    } else {
                        pointsAfter += latlngs[i].length;
                    }
                }
                
                // Проверяем, что останется минимум 2 точки (выбранная + хотя бы одна перед)
                let totalPoints = 0;
                latlngs.forEach(segment => totalPoints += segment.length);
                if (totalPoints - pointsAfter < 2) {
                    alert('Трек должен содержать минимум 2 точки');
                    return;
                }
                
                // Удаляем точки после выбранной в текущем сегменте
                latlngs[targetSegmentIndex] = latlngs[targetSegmentIndex].slice(0, targetPointIndex + 1);
                
                // Удаляем все последующие сегменты
                latlngs.splice(targetSegmentIndex + 1);
                
                // Удаляем сегменты, которые стали пустыми или с одной точкой
                latlngs = latlngs.filter(segment => segment.length >= 2);
                
            } else {
                // Простая полилиния
                if (localIndex >= latlngs.length - 1) {
                    // Это последняя точка, нечего удалять
                    return;
                }
                
                // Проверяем, что останется минимум 2 точки
                if (localIndex + 1 < 2) {
                    alert('Трек должен содержать минимум 2 точки');
                    return;
                }
                
                // Удаляем все точки после выбранной
                latlngs = latlngs.slice(0, localIndex + 1);
            }
            
            // Обновляем полилинию
            layer.setLatLngs(latlngs);
            
            // Пересоздаем маркеры редактирования
            disableTrackEditing(trackIndex);
            enableTrackEditing(trackIndex);
            
            // Обновляем GeoJSON данных трека
            updateTrackGeoJSON(trackIndex);
            updateTrackMarkers(trackIndex);
        }
        
        // Функция удаления всех точек перед выбранной точкой
        function deletePointsBefore(markerData) {
            const { layer, pointIndex, originalPointIndex, startCoordIndex = 0 } = markerData;
            const trackIndex = editingTrackIndex;
            
            if (trackIndex === null || !layer) {
                return;
            }
            
            let latlngs = layer.getLatLngs();
            let isMultiSegment = false;
            const localIndex = originalPointIndex - startCoordIndex;
            if (localIndex < 0) {
                return;
            }
            
            // Обрабатываем случай массива массивов
            if (Array.isArray(latlngs[0]) && latlngs[0].length > 0 && typeof latlngs[0][0] === 'object' && 'lat' in latlngs[0][0]) {
                isMultiSegment = true;
            }
            
            if (isMultiSegment) {
                // Многосегментная полилиния
                let currentIndex = 0;
                let targetSegmentIndex = -1;
                let targetPointIndex = -1;
                
                // Находим сегмент и точку
                for (let i = 0; i < latlngs.length; i++) {
                    if (currentIndex + latlngs[i].length > localIndex) {
                        targetSegmentIndex = i;
                        targetPointIndex = localIndex - currentIndex;
                        break;
                    }
                    currentIndex += latlngs[i].length;
                }
                
                if (targetSegmentIndex === -1) {
                    return;
                }
                
                // Подсчитываем общее количество точек перед выбранной
                let pointsBefore = 0;
                for (let i = 0; i < targetSegmentIndex; i++) {
                    pointsBefore += latlngs[i].length;
                }
                pointsBefore += targetPointIndex;
                
                // Проверяем, что останется минимум 2 точки (выбранная + хотя бы одна после)
                let totalPoints = 0;
                latlngs.forEach(segment => totalPoints += segment.length);
                if (totalPoints - pointsBefore < 2) {
                    alert('Трек должен содержать минимум 2 точки');
                    return;
                }
                
                // Удаляем точки перед выбранной в текущем сегменте
                const remainingInSegment = latlngs[targetSegmentIndex].slice(targetPointIndex);
                latlngs[targetSegmentIndex] = remainingInSegment;
                
                // Удаляем все предыдущие сегменты
                latlngs.splice(0, targetSegmentIndex);
                
                // Удаляем сегменты, которые стали пустыми или с одной точкой
                latlngs = latlngs.filter(segment => segment.length >= 2);
                
            } else {
                // Простая полилиния
                if (localIndex <= 0) {
                    // Это первая точка, нечего удалять
                    return;
                }
                
                // Проверяем, что останется минимум 2 точки
                if (latlngs.length - localIndex < 2) {
                    alert('Трек должен содержать минимум 2 точки');
                    return;
                }
                
                // Удаляем все точки перед выбранной
                latlngs = latlngs.slice(localIndex);
            }
            
            // Обновляем полилинию
            layer.setLatLngs(latlngs);
            
            // Пересоздаем маркеры редактирования
            disableTrackEditing(trackIndex);
            enableTrackEditing(trackIndex);
            
            // Обновляем GeoJSON данных трека
            updateTrackGeoJSON(trackIndex);
            updateTrackMarkers(trackIndex);
        }
        
        // Функция пересчёта времени от точки до конца трека на основе заданной скорости
        function setSpeedFromPoint(markerData) {
            const { originalPointIndex, featureIndex = 0 } = markerData || {};
            const trackIndex = editingTrackIndex;

            if (trackIndex === null || originalPointIndex === undefined || originalPointIndex < 0) {
                return;
            }

            const track = tracks[trackIndex];
            if (!track || !track.geoJson || !track.geoJson.features) {
                return;
            }

            // Запрашиваем скорость у пользователя
            const input = prompt(
                'Введите среднюю скорость (км/ч) для пересчёта времени от этой точки до конца трека:',
                '5'
            );

            if (input === null) {
                return; // Пользователь отменил
            }

            const speed = parseFloat(String(input).replace(',', '.'));
            if (isNaN(speed) || speed <= 0) {
                alert('Скорость должна быть положительным числом');
                return;
            }

            // Находим глобальный индекс точки в треке
            const features = track.geoJson.features;
            let globalPointIndex = 0;
            let targetFeatureIndex = -1;
            let localPointIndex = -1;

            for (let fi = 0; fi < features.length; fi++) {
                const feature = features[fi];
                if (!feature || !feature.geometry || feature.geometry.type !== 'LineString') continue;

                const coords = feature.geometry.coordinates;
                if (fi === featureIndex && originalPointIndex < coords.length) {
                    targetFeatureIndex = fi;
                    localPointIndex = originalPointIndex;
                    globalPointIndex += originalPointIndex;
                    break;
                }
                globalPointIndex += coords.length;
            }

            if (targetFeatureIndex === -1) {
                alert('Не удалось найти точку в треке');
                return;
            }

            // Пересчитываем время от найденной точки до конца трека
            let currentTime = null;
            let pointIndex = 0;

            features.forEach((feature, fi) => {
                if (!feature || !feature.geometry || feature.geometry.type !== 'LineString') return;

                const coords = feature.geometry.coordinates;
                if (!feature.properties) feature.properties = {};
                if (!feature.properties.coordTimes) feature.properties.coordTimes = [];

                const coordTimes = feature.properties.coordTimes;

                for (let i = 0; i < coords.length; i++) {
                    if (pointIndex < globalPointIndex) {
                        // До целевой точки - сохраняем существующее время
                        if (i < coordTimes.length && coordTimes[i]) {
                            currentTime = new Date(coordTimes[i]);
                        }
                    } else if (pointIndex === globalPointIndex) {
                        // Целевая точка - используем существующее время или текущее
                        if (i < coordTimes.length && coordTimes[i]) {
                            currentTime = new Date(coordTimes[i]);
                        } else if (currentTime) {
                            coordTimes[i] = currentTime.toISOString();
                        } else {
                            currentTime = new Date();
                            coordTimes[i] = currentTime.toISOString();
                        }
                    } else {
                        // После целевой точки - пересчитываем время
                        if (currentTime && i > 0) {
                            const [lon1, lat1] = coords[i - 1];
                            const [lon2, lat2] = coords[i];
                            const distance = calculateDistance(lat1, lon1, lat2, lon2);
                            const timeHours = distance / speed;
                            const timeMs = timeHours * 3600 * 1000;
                            currentTime = new Date(currentTime.getTime() + timeMs);
                            coordTimes[i] = currentTime.toISOString();
                        }
                    }
                    pointIndex++;
                }
            });

            // Обновляем отображение
            updateMap(trackIndex);
            saveToSessionStorage();

            alert(`Время пересчитано от точки ${globalPointIndex} до конца трека со скоростью ${speed} км/ч`);
        }
        
        // Функция включения режима редактирования для трека
        function enableTrackEditing(trackIndex) {
            // Отключаем редактирование предыдущего трека, если есть
            if (editingTrackIndex !== null && editingTrackIndex !== trackIndex) {
                disableTrackEditing(editingTrackIndex);
            }
            
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                console.error('Некорректный индекс трека:', trackIndex, 'tracks.length:', tracks.length);
                return;
            }
            
            // Убеждаемся, что updateMap был вызван и trackLayers обновлен
            if (trackIndex >= trackLayers.length) {
                console.warn('trackLayers не синхронизирован с tracks, вызываем updateMap()');
                updateMap();
            }
            
            editingTrackIndex = trackIndex;
            const track = tracks[trackIndex];
            let layers = trackLayers[trackIndex];
            
            // Если слои еще не созданы, создаем их
            if (!layers || layers.length === 0) {
                const color = colors[trackIndex % colors.length];
                const result = renderTrack(track, color);
                trackLayers[trackIndex] = result.layers;
                trackStartMarkers[trackIndex] = result.startMarkers;
                trackEndMarkers[trackIndex] = result.endMarkers;
                layers = trackLayers[trackIndex];
            }
            
            const finalLayers = layers;
            finalLayers.forEach(layer => {
                if (layer instanceof L.Polyline && (typeof layer.featureIndex !== 'number' || layer.featureIndex < 0)) {
                    layer.featureIndex = 0;
                }
                if (layer instanceof L.Polyline && typeof layer.startCoordIndex !== 'number') {
                    layer.startCoordIndex = 0;
                }
            });
            
            // Проверяем, является ли трек пустым
            let isEmpty = false;
            if (finalLayers.length === 0) {
                isEmpty = true;
            } else if (finalLayers.length === 1) {
                const latlngs = finalLayers[0].getLatLngs();
                isEmpty = !latlngs || latlngs.length === 0;
            }
            
            // Также проверяем по GeoJSON
            if (!isEmpty && track.geoJson && track.geoJson.features) {
                const hasCoordinates = track.geoJson.features.some(feature => 
                    feature.geometry && 
                    feature.geometry.coordinates && 
                    feature.geometry.coordinates.length > 0
                );
                if (!hasCoordinates) {
                    isEmpty = true;
                }
            }
            
            // Очищаем предыдущие маркеры редактирования
            editMarkers.forEach(marker => map.removeLayer(marker));
            editMarkers = [];
            editMarkerData = [];
            
            // Удаляем предыдущий обработчик клика на карту, если есть
            if (mapClickHandler) {
                map.off('click', mapClickHandler);
                mapClickHandler = null;
            }
            
            // Если трек пустой, добавляем обработчик клика на карту для рисования
            if (isEmpty) {
                // Создаем пустую полилинию, если её нет
                let polyline = null;
                if (finalLayers.length === 0) {
                    polyline = L.polyline([], {
                        color: colors[trackIndex % colors.length],
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);
                    polyline.featureIndex = 0;
                    polyline.startCoordIndex = 0;
                    trackLayers[trackIndex] = [polyline];
                    finalLayers.push(polyline);
                } else {
                    polyline = finalLayers[0];
                    if (typeof polyline.featureIndex !== 'number') {
                        polyline.featureIndex = 0;
                    }
                    if (typeof polyline.startCoordIndex !== 'number') {
                        polyline.startCoordIndex = 0;
                    }
                }
                
                // Обработчик клика на карту для добавления точек
                mapClickHandler = function(e) {
                    const latlng = e.latlng;
                    
                    // Добавляем точку к полилинии
                    const currentLatLngs = polyline.getLatLngs();
                    currentLatLngs.push(latlng);
                    polyline.setLatLngs(currentLatLngs);
                    
                    // Добавляем текущее время для новой точки
                        const currentTime = new Date().toISOString();
                        const track = tracks[trackIndex];
                        const feature = track.geoJson.features[0];
                    if (feature) {
                        if (!feature.properties) {
                            feature.properties = {};
                        }
                        if (!feature.properties.coordTimes) {
                            feature.properties.coordTimes = [];
                        }
                        feature.properties.coordTimes.push(currentTime);
                        
                        // Инициализируем высоту, если её нет
                        if (!feature.properties.elevations) {
                            feature.properties.elevations = [];
                        }
                        // Добавляем null для высоты новой точки (высота неизвестна)
                        feature.properties.elevations.push(null);
                    }
                    
                    // Создаем маркер для новой точки
                    const marker = L.marker(latlng, {
                        draggable: true,
                        icon: L.divIcon({
                            className: 'edit-marker',
                            html: '<div style="background: #ff0000; width: 10px; height: 10px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>',
                            iconSize: [10, 10],
                            iconAnchor: [5, 5]
                        })
                    }).addTo(map);
                    
                    const markerData = {
                        layer: polyline,
                        pointIndex: currentLatLngs.length - 1,
                        originalPointIndex: currentLatLngs.length - 1,
                        featureIndex: 0,
                        startCoordIndex: 0,
                        markerIndex: editMarkers.length
                    };
                    editMarkerData.push(markerData);
                    
                    // Обработчик перемещения маркера
                    marker.on('drag', function(e) {
                        const newLatLng = e.target.getLatLng();
                        const updatedLatLngs = polyline.getLatLngs();
                        updatedLatLngs[markerData.pointIndex] = newLatLng;
                        polyline.setLatLngs(updatedLatLngs);
                        updateTrackGeoJSON(trackIndex);
                    });
                    
                    // Обработчик контекстного меню для маркера
                    marker.on('contextmenu', function(e) {
                        const originalEvent = e.originalEvent || e;
                        showContextMenu(originalEvent, markerData);
                    });
                    
                    editMarkers.push(marker);
                    
                    // Обновляем GeoJSON
                    updateTrackGeoJSON(trackIndex);
                    
                    // Обновляем маркеры начала и конца только для этого трека
                    updateTrackMarkers(trackIndex);
                };
                
                map.on('click', mapClickHandler);
            }
            
            // Создаем маркеры для каждой точки каждого слоя трека (если трек не пустой)
            if (!isEmpty) {
                finalLayers.forEach(layer => {
                if (layer instanceof L.Polyline) {
                    let latlngs = layer.getLatLngs();
                    let isMultiSegment = false;
                    let originalLatLngs = latlngs;
                    
                    // Обрабатываем случай, когда getLatLngs() возвращает массив массивов
                    if (latlngs.length > 0 && Array.isArray(latlngs[0]) && latlngs[0].length > 0 && typeof latlngs[0][0] === 'object' && 'lat' in latlngs[0][0]) {
                        // Это массив массивов (многосегментная полилиния)
                        isMultiSegment = true;
                        latlngs = latlngs.flat();
                    }
                    
                    // Получаем время и высоты точек из GeoJSON для нужного сегмента
                    const track = tracks[trackIndex];
                    const featureIndex = (typeof layer.featureIndex === 'number' && layer.featureIndex >= 0) ? layer.featureIndex : 0;
                    const startOffset = typeof layer.startCoordIndex === 'number' ? layer.startCoordIndex : 0;
                    const feature = track.geoJson.features[featureIndex];
                    const coordTimes = feature && feature.properties && feature.properties.coordTimes ? 
                        feature.properties.coordTimes : [];
                    const elevations = feature && feature.properties && feature.properties.elevations ? 
                        feature.properties.elevations : [];
                    
                    latlngs.forEach((latlng, flatIndex) => {
                        // Проверяем, что это объект LatLng
                        if (!latlng || typeof latlng.lat !== 'number') {
                            return;
                        }
                        
                        // Вычисляем оригинальный индекс точки
                        const originalPointIndex = startOffset + flatIndex;
                        
                        // Получаем время и высоту для этой точки
                        const pointTime = coordTimes[originalPointIndex];
                        const pointElevation = elevations[originalPointIndex];
                        const timeTooltip = formatDateTimeWithTZ(pointTime);
                        
                        // Формируем tooltip с временем и высотой
                        let tooltipText = '';
                        if (timeTooltip) {
                            tooltipText = timeTooltip;
                        }
                        if (pointElevation !== null && pointElevation !== undefined) {
                            if (tooltipText) {
                                tooltipText += '\n';
                            }
                            tooltipText += `Высота: ${pointElevation.toFixed(1)} м`;
                        }
                        
                        const marker = L.marker(latlng, {
                            draggable: true,
                            icon: L.divIcon({
                                className: 'edit-marker',
                                html: '<div style="background: #ff0000; width: 10px; height: 10px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map);
                        
                        // Добавляем tooltip с временем и высотой
                        if (tooltipText) {
                            marker.bindTooltip(tooltipText, {
                                permanent: false,
                                direction: 'top',
                                offset: [0, -10]
                            });
                        }
                        
                        // Сохраняем данные о маркере
                        const markerData = {
                            layer: layer,
                            pointIndex: flatIndex,
                            originalPointIndex: originalPointIndex,
                            featureIndex: featureIndex,
                            startCoordIndex: startOffset,
                            markerIndex: editMarkers.length
                        };
                        editMarkerData.push(markerData);
                        
                        // Обработчик перемещения маркера
                        marker.on('drag', function(e) {
                            const newLatLng = e.target.getLatLng();
                            const localIndex = originalPointIndex - startOffset;
                            
                            // Обновляем координаты в полилинии
                            let updatedLatLngs = layer.getLatLngs();
                            
                            // Обрабатываем случай массива массивов
                            if (isMultiSegment) {
                                // Многосегментная полилиния - находим нужный сегмент и точку
                                let currentIndex = 0;
                                for (let i = 0; i < updatedLatLngs.length; i++) {
                                    if (currentIndex + updatedLatLngs[i].length > localIndex) {
                                        const segmentPointIndex = localIndex - currentIndex;
                                        updatedLatLngs[i][segmentPointIndex] = newLatLng;
                                        break;
                                    }
                                    currentIndex += updatedLatLngs[i].length;
                                }
                            } else {
                                // Простая полилиния
                                if (localIndex >= 0 && localIndex < updatedLatLngs.length) {
                                    updatedLatLngs[localIndex] = newLatLng;
                                }
                            }
                            
                            layer.setLatLngs(updatedLatLngs);
                            
                            // Синхронизируем позиции всех маркеров с полилинией
                            syncEditMarkersWithPolyline();
                            
                            // Обновляем GeoJSON данных трека
                            updateTrackGeoJSON(trackIndex);
                        });
                        
                        // Обработчик контекстного меню (правый клик)
                        marker.on('contextmenu', function(e) {
                            const originalEvent = e.originalEvent || e;
                            showContextMenu(originalEvent, markerData);
                        });
                        
                        editMarkers.push(marker);
                    });
                    
                    // Обработчик клика на полилинию для добавления новой точки
                    layer.on('click', function(e) {
                        e.originalEvent.stopPropagation(); // Предотвращаем всплытие события
                        const clickLatLng = e.latlng;
                        let latlngs = layer.getLatLngs();
                        let isMultiSegment = false;
                        
                        // Обрабатываем случай массива массивов
                        if (latlngs.length > 0 && Array.isArray(latlngs[0]) && latlngs[0].length > 0 && typeof latlngs[0][0] === 'object' && 'lat' in latlngs[0][0]) {
                            isMultiSegment = true;
                        }
                        
                        const featureIndex = (typeof layer.featureIndex === 'number' && layer.featureIndex >= 0) ? layer.featureIndex : 0;
                        const startOffset = typeof layer.startCoordIndex === 'number' ? layer.startCoordIndex : 0;
                        if (isMultiSegment) {
                            // Многосегментная полилиния - находим ближайший сегмент
                            let minDistance = Infinity;
                            let bestSegmentIndex = 0;
                            let bestInsertIndex = 0;
                            
                            latlngs.forEach((segment, segIndex) => {
                                for (let i = 0; i < segment.length - 1; i++) {
                                    const segmentStart = segment[i];
                                    const segmentEnd = segment[i + 1];
                                    
                                    // Вычисляем расстояние от клика до сегмента
                                    const distance = pointToLineDistance(
                                        clickLatLng.lat, clickLatLng.lng,
                                        segmentStart.lat, segmentStart.lng,
                                        segmentEnd.lat, segmentEnd.lng
                                    );
                                    
                                    if (distance < minDistance) {
                                        minDistance = distance;
                                        bestSegmentIndex = segIndex;
                                        bestInsertIndex = i + 1;
                                    }
                                }
                            });
                            
                            // Вставляем точку в найденное место
                            latlngs[bestSegmentIndex].splice(bestInsertIndex, 0, clickLatLng);
                            layer.setLatLngs(latlngs);
                            
                            // Добавляем время и тип сегмента для новой точки
                            const track = tracks[trackIndex];
                            const feature = track.geoJson.features[featureIndex];
                            if (feature) {
                                if (!feature.properties) {
                                    feature.properties = {};
                                }
                                if (!feature.properties.coordTimes) {
                                    feature.properties.coordTimes = [];
                                }

                                // Вычисляем индекс точки в общем массиве координат
                                let totalIndex = startOffset;
                                for (let i = 0; i < bestSegmentIndex; i++) {
                                    totalIndex += latlngs[i].length;
                                }
                                totalIndex += bestInsertIndex;

                                // Вставляем время в нужное место
                                const currentTime = new Date().toISOString();
                                feature.properties.coordTimes.splice(totalIndex, 0, currentTime);

                                // Вставляем высоту (null, так как высота новой точки неизвестна)
                                if (!feature.properties.elevations) {
                                    feature.properties.elevations = [];
                                }
                                feature.properties.elevations.splice(totalIndex, 0, null);
                            }
                            
                            // Пересоздаем маркеры редактирования
                            disableTrackEditing(trackIndex);
                            enableTrackEditing(trackIndex);
                            
                        } else {
                            // Простая полилиния - находим ближайший сегмент
                            let minDistance = Infinity;
                            let bestInsertIndex = 0;
                            
                            for (let i = 0; i < latlngs.length - 1; i++) {
                                const segmentStart = latlngs[i];
                                const segmentEnd = latlngs[i + 1];
                                
                                // Вычисляем расстояние от клика до сегмента
                                const distance = pointToLineDistance(
                                    clickLatLng.lat, clickLatLng.lng,
                                    segmentStart.lat, segmentStart.lng,
                                    segmentEnd.lat, segmentEnd.lng
                                );
                                
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestInsertIndex = i + 1;
                                }
                            }
                            
                            // Вставляем точку в найденное место
                            latlngs.splice(bestInsertIndex, 0, clickLatLng);
                            layer.setLatLngs(latlngs);
                            
                            // Добавляем время и тип сегмента для новой точки
                            const track = tracks[trackIndex];
                            const feature = track.geoJson.features[featureIndex];
                            if (feature) {
                                if (!feature.properties) {
                                    feature.properties = {};
                                }
                                if (!feature.properties.coordTimes) {
                                    feature.properties.coordTimes = [];
                                }

                                const totalIndex = startOffset + bestInsertIndex;

                                // Вставляем время в нужное место
                                const currentTime = new Date().toISOString();
                                feature.properties.coordTimes.splice(totalIndex, 0, currentTime);

                                // Вставляем высоту (null, так как высота новой точки неизвестна)
                                if (!feature.properties.elevations) {
                                    feature.properties.elevations = [];
                                }
                                feature.properties.elevations.splice(totalIndex, 0, null);
                            }
                            
                            // Пересоздаем маркеры редактирования
                            disableTrackEditing(trackIndex);
                            enableTrackEditing(trackIndex);
                        }
                        
                        // Обновляем GeoJSON
                        updateTrackGeoJSON(trackIndex);
                        updateTrackMarkers(trackIndex);
                    });
                }
            });
            }
            
            // Обработчик клика по карте для скрытия контекстного меню (только для непустых треков)
            if (!isEmpty) {
                map.on('click', hideContextMenu);
            }
            
            // Показываем баннер редактирования
            const editingTrackNameEl = document.getElementById('editing-track-name');
            if (editingTrackNameEl) {
                editingTrackNameEl.textContent = track.name;
            }
            if (editingBanner) {
                editingBanner.classList.add('show');
            }
            
            // Обновляем UI
            updateTracksTable();
        }
        
        // Функция отключения режима редактирования для трека
        function disableTrackEditing(trackIndex) {
            if (trackIndex === null || trackIndex < 0 || trackIndex >= trackLayers.length) {
                return;
            }
            
            // Удаляем маркеры редактирования
            editMarkers.forEach(marker => map.removeLayer(marker));
            editMarkers = [];
            editMarkerData = [];
            
            // Удаляем обработчики клика на полилинии
            const layers = trackLayers[trackIndex];
            if (layers) {
                layers.forEach(layer => {
                    if (layer instanceof L.Polyline) {
                        layer.off('click'); // Удаляем все обработчики клика на полилинию
                    }
                });
            }
            
            // Удаляем обработчик клика по карте для скрытия контекстного меню
            map.off('click', hideContextMenu);
            
            // Удаляем обработчик клика по карте для рисования трека
            if (mapClickHandler) {
                map.off('click', mapClickHandler);
                mapClickHandler = null;
            }
            
            // Удаляем обработчики перемещения карты
            if (window.mapMoveHandlers) {
                window.mapMoveHandlers = window.mapMoveHandlers.filter(item => {
                    if (item.map === map) {
                        map.off('moveend', item.handler);
                        return false;
                    }
                    return true;
                });
            }
            
            // Скрываем контекстное меню
            hideContextMenu();
            
            // Обнуляем editingTrackIndex перед обновлением таблицы
            if (editingTrackIndex === trackIndex) {
                editingTrackIndex = null;
            }
            
            // Скрываем баннер редактирования
            if (editingBanner) {
                editingBanner.classList.remove('show');
            }
            
            // Обновляем UI
            updateTracksTable();
        }
        
        // Функция обновления GeoJSON данных трека после редактирования
        function updateTrackGeoJSON(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const layers = trackLayers[trackIndex] || [];
            const currentFeatures = (tracks[trackIndex].geoJson && tracks[trackIndex].geoJson.features) ? 
                tracks[trackIndex].geoJson.features : [];
            
            // Подготовка "корзин" координат для каждого feature, чтобы не терять их порядок
            const featureCoordinates = currentFeatures.length > 0 ? currentFeatures.map(() => []) : [[]];
            
            const normalizeArray = (source, targetLength, filler) => {
                if (!Array.isArray(source)) {
                    return null;
                }
                const result = source.slice(0, targetLength);
                while (result.length < targetLength) {
                    result.push(typeof filler === 'function' ? filler() : filler);
                }
                return result;
            };
            
            layers.forEach(layer => {
                if (!(layer instanceof L.Polyline)) {
                    return;
                }
                
                let latlngs = layer.getLatLngs();
                
                // Обрабатываем случай, когда getLatLngs() возвращает массив массивов
                if (latlngs.length > 0 && Array.isArray(latlngs[0]) && latlngs[0].length > 0 && typeof latlngs[0][0] === 'object' && 'lat' in latlngs[0][0]) {
                    latlngs = latlngs.flat();
                }
                
                const featureIndex = (typeof layer.featureIndex === 'number' && layer.featureIndex >= 0) ? layer.featureIndex : 0;
                const startIndex = typeof layer.startCoordIndex === 'number' ? layer.startCoordIndex : 0;
                while (featureCoordinates.length <= featureIndex) {
                    featureCoordinates.push([]);
                }
                
                const targetCoords = featureCoordinates[featureIndex];
                const originalFeature = currentFeatures[featureIndex] || {};
                const originalProps = originalFeature.properties || {};
                const elevations = originalProps.elevations || [];
                for (let i = 0; i < latlngs.length; i++) {
                    const latlng = latlngs[i];
                    if (latlng && typeof latlng.lat === 'number' && typeof latlng.lng === 'number') {
                        const coordIdx = startIndex + i;
                        const coord = [latlng.lng, latlng.lat];
                        if (coordIdx < elevations.length && elevations[coordIdx] !== null && elevations[coordIdx] !== undefined) {
                            coord.push(elevations[coordIdx]);
                        }
                        targetCoords[coordIdx] = coord;
                    }
                }
            });
            
            const newFeatures = featureCoordinates.map((coordsRaw, featureIndex) => {
                const coordinates = coordsRaw.filter(c => Array.isArray(c));
                const originalFeature = currentFeatures[featureIndex] || {};
                const originalProps = originalFeature.properties || {};
                const properties = { ...originalProps };
                const coordCount = coordinates.length;
                
                // Синхронизируем время
                const coordTimes = normalizeArray(originalProps.coordTimes, coordCount, () => new Date().toISOString());
                if (coordTimes && coordTimes.length > 0) {
                    properties.coordTimes = coordTimes;
                } else {
                    delete properties.coordTimes;
                }
                
                // Синхронизируем высоты
                let elevations = normalizeArray(originalProps.elevations, coordCount, null);
                if (!elevations && coordCount > 0) {
                    elevations = new Array(coordCount).fill(null);
                }
                if (elevations) {
                    properties.elevations = elevations;
                } else {
                    delete properties.elevations;
                }

                return {
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinates
                    },
                    properties: properties
                };
            });
            
            // Обновляем GeoJSON трека
            // Если features пустой, создаем пустой feature для возможности добавления точек
            if (newFeatures.length === 0) {
                newFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: []
                    },
                    properties: {}
                });
            }
            
            tracks[trackIndex].geoJson = {
                type: 'FeatureCollection',
                features: newFeatures
            };
            
            // Сохраняем изменения
            saveToSessionStorage();
        }
        
        // Функция обновления маркеров начала и конца для конкретного трека
        function updateTrackMarkers(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson || !track.geoJson.features) {
                return;
            }
            
            // Удаляем старые маркеры начала и конца
            const oldStartMarkers = trackStartMarkers[trackIndex] || [];
            const oldEndMarkers = trackEndMarkers[trackIndex] || [];
            
            oldStartMarkers.forEach(marker => map.removeLayer(marker));
            oldEndMarkers.forEach(marker => map.removeLayer(marker));
            
            const newStartMarkers = [];
            const newEndMarkers = [];
            
            const features = track.geoJson.features;
            
            features.forEach((feature, featureIndex) => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coordinates = feature.geometry.coordinates;
                    
                    if (coordinates.length > 0) {
                        // Получаем время и высоту для точек этого сегмента
                        const coordTimes = feature.properties && feature.properties.coordTimes ? 
                            feature.properties.coordTimes : [];
                        const elevations = feature.properties && feature.properties.elevations ? 
                            feature.properties.elevations : [];
                        
                        // Маркер начала (зеленый) - только для первого сегмента
                        if (featureIndex === 0) {
                            const [lon, lat] = coordinates[0];
                            const startTime = coordTimes[0];
                            const startElevation = elevations[0];
                        const timeTooltip = formatDateTimeWithTZ(startTime);
                            
                            let tooltipText = 'Начало';
                            if (timeTooltip) {
                                tooltipText += ': ' + timeTooltip;
                            }
                            if (startElevation !== null && startElevation !== undefined) {
                                tooltipText += '\nВысота: ' + startElevation.toFixed(1) + ' м';
                            }
                            
                            const startMarker = L.marker([lat, lon], {
                                icon: L.divIcon({
                                    className: 'track-start-marker',
                                    html: '<div style="background: #28a745; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>',
                                    iconSize: [12, 12],
                                    iconAnchor: [6, 6]
                                })
                            }).addTo(map);
                            
                            // Добавляем tooltip с временем и высотой
                            if (tooltipText !== 'Начало') {
                                startMarker.bindTooltip(tooltipText, {
                                    permanent: false,
                                    direction: 'top',
                                    offset: [0, -10]
                                });
                            }
                            
                            newStartMarkers.push(startMarker);
                        }
                        
                        // Маркер конца (красный) - только для последнего сегмента
                        if (featureIndex === features.length - 1) {
                            const [lon, lat] = coordinates[coordinates.length - 1];
                            const endTime = coordTimes[coordTimes.length - 1];
                            const endElevation = elevations[elevations.length - 1];
                        const timeTooltip = formatDateTimeWithTZ(endTime);
                            
                            let tooltipText = 'Конец';
                            if (timeTooltip) {
                                tooltipText += ': ' + timeTooltip;
                            }
                            if (endElevation !== null && endElevation !== undefined) {
                                tooltipText += '\nВысота: ' + endElevation.toFixed(1) + ' м';
                            }
                            
                            const endMarker = L.marker([lat, lon], {
                                icon: L.divIcon({
                                    className: 'track-end-marker',
                                    html: '<div style="background: #dc3545; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>',
                                    iconSize: [12, 12],
                                    iconAnchor: [6, 6]
                                })
                            }).addTo(map);
                            
                            // Добавляем tooltip с временем и высотой
                            if (tooltipText !== 'Конец') {
                                endMarker.bindTooltip(tooltipText, {
                                    permanent: false,
                                    direction: 'top',
                                    offset: [0, -10]
                                });
                            }
                            
                            newEndMarkers.push(endMarker);
                        }
                    }
                }
            });
            
            // Обновляем массивы маркеров
            trackStartMarkers[trackIndex] = newStartMarkers;
            trackEndMarkers[trackIndex] = newEndMarkers;
            
            // Применяем видимость
            if (!trackVisibility[trackIndex]) {
                newStartMarkers.forEach(marker => map.removeLayer(marker));
                newEndMarkers.forEach(marker => map.removeLayer(marker));
            }
        }
        
        // Функция обновления кнопки редактирования
        function updateEditButton(trackIndex, isActive) {
            // Обновляем таблицу для отображения значка редактирования
            updateTracksTable();
            
            // Также обновляем кнопку в контекстном меню, если оно открыто
            const tableBody = document.getElementById('tracks-table-body');
            const row = tableBody.querySelector(`tr[data-track-index="${trackIndex}"]`);
            if (row) {
                const editButton = row.querySelector('.edit-button');
                if (editButton) {
                    if (isActive) {
                        editButton.classList.add('active');
                        editButton.textContent = 'Сохранить';
                    } else {
                        editButton.classList.remove('active');
                        editButton.textContent = 'Редактировать';
                    }
                }
            }
        }
        
        // Функция обновления карты
        function clearTrackLayers(trackIndex) {
            const layers = trackLayers[trackIndex] || [];
            layers.forEach(layer => map.removeLayer(layer));
            
            const startMarkers = trackStartMarkers[trackIndex] || [];
            startMarkers.forEach(marker => map.removeLayer(marker));
            
            const endMarkers = trackEndMarkers[trackIndex] || [];
            endMarkers.forEach(marker => map.removeLayer(marker));
            
            trackLayers[trackIndex] = [];
            trackStartMarkers[trackIndex] = [];
            trackEndMarkers[trackIndex] = [];
        }
        
        function renderTrackAtIndex(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            if (typeof trackVisibility[trackIndex] === 'undefined') {
                trackVisibility[trackIndex] = true;
            }
            
            const color = colors[trackIndex % colors.length];
            const result = renderTrack(tracks[trackIndex], color);
            trackLayers[trackIndex] = result.layers;
            trackStartMarkers[trackIndex] = result.startMarkers;
            trackEndMarkers[trackIndex] = result.endMarkers;
            
            // Применяем состояние видимости
            if (!trackVisibility[trackIndex]) {
                result.layers.forEach(layer => {
                    map.removeLayer(layer);
                });
                result.startMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
                result.endMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
            }
        }
        
        function updateMap(targetTrackIndex) {
            // Точечное обновление конкретного трека
            if (typeof targetTrackIndex === 'number' && targetTrackIndex >= 0 && targetTrackIndex < tracks.length) {
                clearTrackLayers(targetTrackIndex);
                renderTrackAtIndex(targetTrackIndex);
                clearButton.disabled = tracks.length === 0;
                updateTracksTable();
                return;
            }
            
            // Полное обновление
            trackLayers.forEach((_, idx) => clearTrackLayers(idx));
            trackLayers = [];
            trackStartMarkers = [];
            trackEndMarkers = [];
            
            // Подгоняем массив видимости под количество треков
            trackVisibility = trackVisibility.slice(0, tracks.length);
            while (trackVisibility.length < tracks.length) {
                trackVisibility.push(true); // По умолчанию все треки видимы
            }
            
            // Отрисовка всех треков с учетом видимости
            tracks.forEach((_, index) => {
                renderTrackAtIndex(index);
            });
            
            // Обновление UI
            clearButton.disabled = tracks.length === 0;
            updateTracksTable();
        }
        
        // Функция показа/скрытия трека
        function toggleTrackVisibility(trackIndex, isVisible) {
            if (trackIndex < 0 || trackIndex >= trackLayers.length) {
                return;
            }
            
            trackVisibility[trackIndex] = isVisible;
            const layers = trackLayers[trackIndex];
            const startMarkers = trackStartMarkers[trackIndex] || [];
            const endMarkers = trackEndMarkers[trackIndex] || [];
            
            if (isVisible) {
                // Показываем трек
                layers.forEach(layer => {
                    layer.addTo(map);
                });
                startMarkers.forEach(marker => {
                    marker.addTo(map);
                });
                endMarkers.forEach(marker => {
                    marker.addTo(map);
                });
            } else {
                // Скрываем трек
                layers.forEach(layer => {
                    map.removeLayer(layer);
                });
                startMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
                endMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
            }
            
            // Сохраняем состояние видимости
            saveTrackVisibility();
        }
        
        // Функция позиционирования карты на выбранный трек
        function focusOnTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= trackLayers.length) {
                return;
            }
            
            const layers = trackLayers[trackIndex];
            if (!layers || layers.length === 0) {
                return;
            }
            
            try {
                // Используем все слои трека
                const group = new L.featureGroup(layers);
                const bounds = group.getBounds();
                
                if (bounds && bounds.isValid && bounds.isValid()) {
                    map.fitBounds(bounds.pad(0.1));
                } else if (bounds) {
                    // Если isValid не доступен, пробуем просто fitBounds
                    map.fitBounds(bounds.pad(0.1));
                }
            } catch (error) {
                console.error('Error focusing on track:', error);
            }
        }
        
        // Функция позиционирования на первую точку трека
        function focusOnTrackStart(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson || !track.geoJson.features) {
                return;
            }
            
            const features = track.geoJson.features;
            
            if (features.length === 0) {
                return;
            }
            
            const firstFeature = features[0];
            if (firstFeature.geometry && firstFeature.geometry.type === 'LineString') {
                const coordinates = firstFeature.geometry.coordinates;
                if (coordinates.length > 0) {
                    const [lon, lat] = coordinates[0];
                    map.setView([lat, lon], Math.max(map.getZoom(), 15));
                }
            }
        }
        
        // Функция позиционирования на последнюю точку трека
        function focusOnTrackEnd(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson || !track.geoJson.features) {
                return;
            }
            
            const features = track.geoJson.features;
            
            if (features.length === 0) {
                return;
            }
            
            const lastFeature = features[features.length - 1];
            if (lastFeature.geometry && lastFeature.geometry.type === 'LineString') {
                const coordinates = lastFeature.geometry.coordinates;
                if (coordinates.length > 0) {
                    const [lon, lat] = coordinates[coordinates.length - 1];
                    map.setView([lat, lon], Math.max(map.getZoom(), 15));
                }
            }
        }
        
        // Функция вычисления расстояния между двумя точками (формула гаверсинуса)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Радиус Земли в километрах
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }
        
        // Функция вычисления расстояния от точки до сегмента линии (в метрах)
        // Использует упрощенную формулу для небольших расстояний
        function pointToLineDistance(pointLat, pointLon, lineStartLat, lineStartLon, lineEndLat, lineEndLon) {
            // Преобразуем координаты в метры (приблизительно)
            const R = 6371000; // Радиус Земли в метрах
            
            // Вычисляем векторы
            const dx = (lineEndLon - lineStartLon) * Math.cos((lineStartLat + lineEndLat) / 2 * Math.PI / 180) * R * Math.PI / 180;
            const dy = (lineEndLat - lineStartLat) * R * Math.PI / 180;
            
            const px = (pointLon - lineStartLon) * Math.cos((lineStartLat + pointLat) / 2 * Math.PI / 180) * R * Math.PI / 180;
            const py = (pointLat - lineStartLat) * R * Math.PI / 180;
            
            // Вычисляем проекцию точки на линию
            const lineLengthSq = dx * dx + dy * dy;
            if (lineLengthSq === 0) {
                // Точки начала и конца совпадают
                return Math.sqrt(px * px + py * py);
            }
            
            const t = Math.max(0, Math.min(1, (px * dx + py * dy) / lineLengthSq));
            
            // Ближайшая точка на сегменте
            const projX = lineStartLon + (lineEndLon - lineStartLon) * t;
            const projY = lineStartLat + (lineEndLat - lineStartLat) * t;
            
            // Расстояние от точки до проекции
            return calculateDistance(pointLat, pointLon, projY, projX) * 1000; // в метрах
        }
        
        // Функция вычисления длины трека в километрах
        function calculateTrackLength(track) {
            let totalLength = 0;
            
            track.geoJson.features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coordinates = feature.geometry.coordinates;
                    
                    for (let i = 0; i < coordinates.length - 1; i++) {
                        const [lon1, lat1] = coordinates[i];
                        const [lon2, lat2] = coordinates[i + 1];
                        totalLength += calculateDistance(lat1, lon1, lat2, lon2);
                    }
                }
            });
            
            return totalLength;
        }

        // Средняя скорость по треку (км/ч) при наличии времени начала и конца
        function calculateTrackAverageSpeed(track) {
            if (!track || !track.geoJson) {
                return null;
            }
            
            const lengthKm = calculateTrackLength(track);
            if (lengthKm <= 0) {
                return null;
            }
            
            const firstTimeStr = findFirstCoordTime(track.geoJson);
            const lastTimeStr = findLastCoordTime(track.geoJson);
            if (!firstTimeStr || !lastTimeStr) {
                return null;
            }
            
            const start = new Date(firstTimeStr);
            const end = new Date(lastTimeStr);
            if (isNaN(start.getTime()) || isNaN(end.getTime()) || end <= start) {
                return null;
            }
            
            const hours = (end - start) / 3600000;
            if (hours <= 0) {
                return null;
            }
            
            return lengthKm / hours;
        }
        
        // Функция обновления списка треков
        function updateTracksTable() {
            const tracksList = document.getElementById('tracks-list');
            const trackCounter = document.getElementById('track-counter');
            const trackDetails = document.getElementById('track-details');
            
            // Обновляем счетчик
            trackCounter.textContent = `Треков: ${tracks.length}`;
            
            tracksList.innerHTML = '';
            
            if (tracks.length === 0) {
                trackDetails.classList.remove('show');
                return;
            }
            
            tracks.forEach((track, index) => {
                const color = colors[index % colors.length];
                const item = document.createElement('li');
                item.className = 'track-item';
                item.setAttribute('data-track-index', index);
                
                // Подсчет количества точек
                let pointCount = 0;
                track.geoJson.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.type === 'LineString') {
                        pointCount += feature.geometry.coordinates.length;
                    }
                });
                
                // Вычисление длины трека
                const trackLength = calculateTrackLength(track);
                const lengthText = trackLength > 0 ? trackLength.toFixed(2) : '0.00';
                
                const isVisible = trackVisibility[index] !== false;
                const isEditing = editingTrackIndex === index;
                const isSelected = selectedTrackIndex === index;
                
                if (isSelected) {
                    item.classList.add('selected');
                }
                if (isEditing) {
                    item.classList.add('editing');
                }
                
                item.innerHTML = `
                    <div class="track-item-header">
                        <div class="track-color-swatch" style="background-color: ${color}"></div>
                        <div class="track-name">${escapeHtml(track.name)}${isEditing ? ' ✏️' : ''}</div>
                        <input type="checkbox" class="track-visibility-toggle" 
                               data-track-index="${index}" 
                               ${isVisible ? 'checked' : ''}
                               onclick="event.stopPropagation()">
                    </div>
                    <div class="track-actions">
                        <button class="track-action-btn" data-action="start" data-track-index="${index}">Начало</button>
                        <button class="track-action-btn" data-action="end" data-track-index="${index}">Конец</button>
                        <button class="track-action-btn more-btn" data-action="more" data-track-index="${index}">⋯</button>
                    </div>
                `;
                
                // Обработчик клика на элемент списка
                item.addEventListener('click', function(e) {
                    if (e.target.type === 'checkbox' || e.target.closest('.track-action-btn')) {
                        return;
                    }
                    selectTrack(index);
                });
                
                // Обработчики кнопок действий
                item.querySelectorAll('.track-action-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const action = this.getAttribute('data-action');
                        const trackIdx = parseInt(this.getAttribute('data-track-index'));
                        
                        if (action === 'start') {
                            focusOnTrackStart(trackIdx);
                        } else if (action === 'end') {
                            focusOnTrackEnd(trackIdx);
                        } else if (action === 'more') {
                            showMoreMenu(e, trackIdx);
                        }
                    });
                });
                
                // Обработчик чекбокса видимости
                const checkbox = item.querySelector('.track-visibility-toggle');
                checkbox.addEventListener('change', function(e) {
                    e.stopPropagation();
                    const trackIdx = parseInt(this.getAttribute('data-track-index'));
                    toggleTrackVisibility(trackIdx, this.checked);
                });
                
                tracksList.appendChild(item);
            });
            
            // Обновляем детали выбранного трека
            if (selectedTrackIndex !== null) {
                updateTrackDetails(selectedTrackIndex);
            }
        }
        
        // Функция выбора трека
        function selectTrack(trackIndex) {
            selectedTrackIndex = trackIndex;
            updateTracksTable();
            updateTrackDetails(trackIndex);
        }
        
        // Функция обновления деталей трека
        function updateTrackDetails(trackIndex) {
            const trackDetails = document.getElementById('track-details');
            const trackDetailsName = document.getElementById('track-details-name');
            const trackDetailsStats = document.getElementById('track-details-stats');
            const trackDetailsEdit = document.getElementById('track-details-edit');
            
            if (trackIndex === null || trackIndex < 0 || trackIndex >= tracks.length) {
                trackDetails.classList.remove('show');
                return;
            }
            
            const track = tracks[trackIndex];
            trackDetails.classList.add('show');
            trackDetailsName.textContent = track.name;
            
            // Подсчет статистики
            let pointCount = 0;
            track.geoJson.features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    pointCount += feature.geometry.coordinates.length;
                }
            });
            
            const trackLength = calculateTrackLength(track);
            const lengthText = trackLength > 0 ? trackLength.toFixed(2) : '0.00';
            
                let hasElevations = false;
            let hasTime = false;
            let firstTimeText = '';
            let lastTimeText = '';
            const firstTimeStr = findFirstCoordTime(track.geoJson);
            const lastTimeStr = findLastCoordTime(track.geoJson);
            if (firstTimeStr) {
                const d = new Date(firstTimeStr);
                if (!isNaN(d.getTime())) {
                    firstTimeText = formatDateTimeWithTZ(d);
                    hasTime = true;
                }
            }
            if (lastTimeStr) {
                const d = new Date(lastTimeStr);
                if (!isNaN(d.getTime())) {
                    lastTimeText = formatDateTimeWithTZ(d);
                    hasTime = true;
                }
            }
                track.geoJson.features.forEach(feature => {
                    if (feature.properties && feature.properties.elevations) {
                        const elevations = feature.properties.elevations;
                        if (elevations.some(e => e !== null && e !== undefined)) {
                            hasElevations = true;
                        }
                    }
                    if (feature.properties && feature.properties.coordTimes) {
                        const coordTimes = feature.properties.coordTimes;
                        if (coordTimes.some(t => t !== null && t !== undefined && t !== '')) {
                            hasTime = true;
                        }
                    }
                });

            // Средняя скорость (если есть время начала/конца)
            let avgSpeedText = '';
            if (firstTimeStr && lastTimeStr) {
                const startDate = new Date(firstTimeStr);
                const endDate = new Date(lastTimeStr);
                if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && endDate > startDate) {
                    const hours = (endDate - startDate) / 3600000;
                    if (hours > 0 && trackLength > 0) {
                        const avgSpeed = trackLength / hours;
                        avgSpeedText = `<div class="track-details-stats-item">Ср. скорость: ${avgSpeed.toFixed(2)} км/ч</div>`;
                    }
                }
            }
                
            trackDetailsStats.innerHTML = `
                <div class="track-details-stats-item">Точек: ${pointCount}</div>
                ${trackLength > 0 ? `<div class="track-details-stats-item">Длина: ${lengthText} км</div>` : ''}
                ${firstTimeText ? `<div class="track-details-stats-item">Начало: ${firstTimeText}</div>` : (hasTime ? '<div class="track-details-stats-item">Время: есть</div>' : '')}
                ${lastTimeText ? `<div class="track-details-stats-item">Конец: ${lastTimeText}</div>` : ''}
                ${avgSpeedText}
            `;
            
            // Обновляем кнопку редактирования
            if (editingTrackIndex === trackIndex) {
                trackDetailsEdit.textContent = 'Завершить редактирование';
            } else {
                trackDetailsEdit.textContent = 'Редактировать';
            }
        }
        
        // Функция показа меню More
        let currentMoreMenuTrackIndex = null;
        function showMoreMenu(event, trackIndex) {
            const moreMenu = document.getElementById('more-menu');
            const rect = event.target.getBoundingClientRect();
            
            moreMenu.style.display = 'block';
            moreMenu.style.left = rect.left + 'px';
            moreMenu.style.top = (rect.bottom + 5) + 'px';
            moreMenu.classList.add('show');
            currentMoreMenuTrackIndex = trackIndex;
            
            // Обновляем текст кнопки редактирования в меню
            const moreEdit = document.getElementById('more-edit');
                if (editingTrackIndex === trackIndex) {
                moreEdit.textContent = 'Сохранить';
                } else {
                moreEdit.textContent = 'Редактировать';
            }
            
            setTimeout(() => {
                document.addEventListener('click', hideMoreMenuOnClick, true);
            }, 0);
        }
        
        function hideMoreMenuOnClick(event) {
            const moreMenu = document.getElementById('more-menu');
            if (moreMenu && !moreMenu.contains(event.target) && !event.target.closest('.more-btn')) {
                hideMoreMenu();
                document.removeEventListener('click', hideMoreMenuOnClick, true);
            }
        }
        
        function hideMoreMenu() {
            const moreMenu = document.getElementById('more-menu');
            if (moreMenu) {
                moreMenu.classList.remove('show');
                moreMenu.style.display = 'none';
            }
            currentMoreMenuTrackIndex = null;
        }
        
        // Функция переименования трека
        function renameTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track) {
                return;
            }
            
            const currentName = track.name;
            const newName = prompt('Введите новое имя трека:', currentName);
            
            if (newName === null) {
                // Пользователь отменил ввод
                return;
            }
            
            if (newName.trim() === '') {
                alert('Имя трека не может быть пустым');
                return;
            }
            
            const trimmedName = newName.trim();
            
            // Проверяем, нет ли уже трека с таким именем
            const existingIndex = tracks.findIndex((track, index) => 
                index !== trackIndex && track.name === trimmedName
            );
            
            if (existingIndex !== -1) {
                alert('Трек с таким именем уже существует');
                return;
            }
            
            // Обновляем имя трека
            track.name = trimmedName;
            
            // Обновляем таблицу
            updateTracksTable();
            
            // Сохраняем изменения
            saveToSessionStorage();
        }
        
        // Функция конвертации GeoJSON в GPX
        function geoJsonToGpx(geoJson, trackName) {
            let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
            gpx += '<gpx version="1.1" creator="GPX Tracker" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n';
            gpx += `  <metadata>\n    <name>${escapeXml(trackName)}</name>\n  </metadata>\n`;
            
            geoJson.features.forEach((feature, index) => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    gpx += '  <trk>\n';
                    gpx += `    <name>${escapeXml(trackName)}${geoJson.features.length > 1 ? ' - Segment ' + (index + 1) : ''}</name>\n`;
                    gpx += '    <trkseg>\n';
                    
                    // Получаем время точек из properties
                    const coordTimes = feature.properties && feature.properties.coordTimes ? feature.properties.coordTimes : [];
                    
                    feature.geometry.coordinates.forEach((coord, coordIndex) => {
                        const lat = coord[1];
                        const lon = coord[0];
                        const eleFromCoord = coord.length > 2 ? coord[2] : null;
                        const ele = (eleFromCoord !== null && eleFromCoord !== undefined) ? eleFromCoord : null;
                        gpx += `      <trkpt lat="${lat}" lon="${lon}">\n`;
                        if (coord.length > 2 && coord[2] !== undefined) {
                            gpx += `        <ele>${coord[2]}</ele>\n`;
                        }
                        // Добавляем время, если оно есть
                        if (coordTimes[coordIndex]) {
                            const timeStr = formatIsoTimeNoMs(coordTimes[coordIndex]);
                            if (timeStr) {
                                gpx += `        <time>${timeStr}</time>\n`;
                            }
                        }
                        gpx += '      </trkpt>\n';
                    });
                    
                    gpx += '    </trkseg>\n';
                    gpx += '  </trk>\n';
                }
            });
            
            gpx += '</gpx>';
            return gpx;
        }
        
        function mapHexToGarminColor(hex) {
            const normalized = (hex || '').toUpperCase();
            const map = {
                '#FF0000': 'Red',
                '#00FF00': 'Green',
                '#0000FF': 'Blue',
                '#FFFF00': 'Yellow',
                '#FF00FF': 'Magenta',
                '#00FFFF': 'Cyan',
                '#FFA500': 'Orange',
                '#800080': 'Purple',
                '#FFC0CB': 'Pink',
                '#A52A2A': 'Brown'
            };
            return map[normalized] || 'Blue';
        }
        
        function formatIsoTimeZ(value) {
            if (!value) return null;
            const d = new Date(value);
            if (isNaN(d.getTime())) return null;
            return d.toISOString();
        }
        
        function formatIsoTimeNoMs(value) {
            const iso = formatIsoTimeZ(value);
            if (!iso) return null;
            return iso.replace(/\.\d{3}Z$/, 'Z');
        }
        
        function formatLocalDateTime(value) {
            const d = new Date(value);
            if (isNaN(d.getTime())) return null;
            const pad = (n) => String(n).padStart(2, '0');
            const yyyy = d.getFullYear();
            const mm = pad(d.getMonth() + 1);
            const dd = pad(d.getDate());
            const hh = pad(d.getHours());
            const mi = pad(d.getMinutes());
            const ss = pad(d.getSeconds());
            return `${yyyy}-${mm}-${dd} ${hh}:${mi}:${ss}`;
        }

        function getBrowserTimeZone() {
            try {
                return Intl.DateTimeFormat().resolvedOptions().timeZone || 'Local';
            } catch (e) {
                return 'Local';
            }
        }

        function formatOffset(date) {
            const offsetMinutes = -date.getTimezoneOffset(); // переходим в привычный знак
            const sign = offsetMinutes >= 0 ? '+' : '-';
            const abs = Math.abs(offsetMinutes);
            const hh = String(Math.floor(abs / 60)).padStart(2, '0');
            const mm = String(abs % 60).padStart(2, '0');
            return `UTC${sign}${hh}:${mm}`;
        }

        function formatDateTimeWithTZ(value) {
            if (!value) return '';
            const d = new Date(value);
            if (isNaN(d.getTime())) return '';
            const tz = getBrowserTimeZone();
            const offset = formatOffset(d);
            const localized = d.toLocaleString('ru-RU', { timeZone: tz, timeZoneName: 'short' });
            return `${localized} (${offset})`;
        }
        
        function findFirstCoordTime(geoJson) {
            for (const feature of geoJson.features || []) {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coordTimes = feature.properties && feature.properties.coordTimes ? feature.properties.coordTimes : [];
                    for (const t of coordTimes) {
                        const normalized = formatIsoTimeNoMs(t);
                        if (normalized) return normalized;
                    }
                }
            }
            return null;
        }
        
        function findLastCoordTime(geoJson) {
            const features = geoJson.features || [];
            for (let f = features.length - 1; f >= 0; f--) {
                const feature = features[f];
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coordTimes = feature.properties && feature.properties.coordTimes ? feature.properties.coordTimes : [];
                    for (let i = coordTimes.length - 1; i >= 0; i--) {
                        const normalized = formatIsoTimeNoMs(coordTimes[i]);
                        if (normalized) return normalized;
                    }
                }
            }
            return null;
        }
        
        // GPX Garmin-совместимый экспорт
        function geoJsonToGarminGpx(geoJson, trackName, colorHex) {
            const displayColor = mapHexToGarminColor(colorHex);
            const firstTime = findFirstCoordTime(geoJson);
            const lastTime = findLastCoordTime(geoJson);
            const metaTime = firstTime || formatIsoTimeNoMs(new Date().toISOString());
            const trackNameFormatted = formatLocalDateTime(lastTime) || trackName;
            
            let gpx = '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n';
            gpx += '<gpx xmlns="http://www.topografix.com/GPX/1/1" ';
            gpx += 'xmlns:gpxx="http://www.garmin.com/xmlschemas/GpxExtensions/v3" ';
            gpx += 'xmlns:wptx1="http://www.garmin.com/xmlschemas/WaypointExtension/v1" ';
            gpx += 'xmlns:gpxtpx="http://www.garmin.com/xmlschemas/TrackPointExtension/v1" ';
            gpx += 'creator="Astro 320" version="1.1" ';
            gpx += 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ';
            gpx += 'xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd ';
            gpx += 'http://www.garmin.com/xmlschemas/GpxExtensions/v3 http://www8.garmin.com/xmlschemas/GpxExtensionsv3.xsd ';
            gpx += 'http://www.garmin.com/xmlschemas/WaypointExtension/v1 http://www8.garmin.com/xmlschemas/WaypointExtensionv1.xsd ';
            gpx += 'http://www.garmin.com/xmlschemas/TrackPointExtension/v1 http://www.garmin.com/xmlschemas/TrackPointExtensionv1.xsd">';
            
            gpx += `<metadata><link href="http://www.garmin.com"><text>Garmin International</text></link><time>${metaTime}</time></metadata>`;
            
            geoJson.features.forEach((feature, index) => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coordTimes = feature.properties && feature.properties.coordTimes ? feature.properties.coordTimes : [];
                    const elevations = feature.properties && feature.properties.elevations ? feature.properties.elevations : [];
                    
                    gpx += `<trk><name>${escapeXml(trackNameFormatted)}${geoJson.features.length > 1 ? ' - Segment ' + (index + 1) : ''}</name>`;
                    gpx += `<extensions><gpxx:TrackExtension><gpxx:DisplayColor>${displayColor}</gpxx:DisplayColor></gpxx:TrackExtension></extensions>`;
                    gpx += '<trkseg>';
                    
                    feature.geometry.coordinates.forEach((coord, coordIndex) => {
                        const lat = Number(coord[1]);
                        const lon = Number(coord[0]);
                        const ele = (coord.length > 2 && coord[2] !== undefined && coord[2] !== null) ? coord[2] : null;
                        const time = formatIsoTimeNoMs(coordTimes[coordIndex]);
                        
                        gpx += `<trkpt lat="${lat.toFixed(10)}" lon="${lon.toFixed(10)}">`;
                        if (ele !== null && ele !== undefined && !isNaN(ele)) {
                            gpx += `<ele>${Number(ele).toFixed(2)}</ele>`;
                        }
                        if (time) {
                            gpx += `<time>${time}</time>`;
                        }
                        gpx += `</trkpt>`;
                    });
                    
                    gpx += '</trkseg></trk>';
                }
            });
            
            gpx += '</gpx>';
            return gpx;
        }
        
        // Функция экранирования XML
        function escapeXml(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
        
        // Функция сохранения трека в файл
        function saveTrackToFile(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson) {
                return;
            }
            
            const gpxContent = geoJsonToGpx(track.geoJson, track.name);
            
            // Создаем Blob с содержимым GPX
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml;charset=utf-8' });
            
            // Создаем ссылку для скачивания
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            
            // Определяем имя файла
            let fileName = track.name;
            if (!fileName.toLowerCase().endsWith('.gpx')) {
                fileName += '.gpx';
            }
            link.download = fileName;
            
            // Добавляем ссылку в DOM, кликаем и удаляем
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Освобождаем URL
            URL.revokeObjectURL(url);
        }
        
        function saveTrackToGarminFile(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson) {
                return;
            }
            
            const colorHex = colors[trackIndex % colors.length];
            const gpxContent = geoJsonToGarminGpx(track.geoJson, track.name, colorHex);
            
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            
            let fileName = track.name;
            if (!fileName.toLowerCase().endsWith('.gpx')) {
                fileName += '.gpx';
            }
            link.download = fileName;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // Функция клонирования трека
        function cloneTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const originalTrack = tracks[trackIndex];
            if (!originalTrack || !originalTrack.geoJson) {
                return;
            }
            
            // Создаем глубокую копию GeoJSON
            const clonedGeoJson = JSON.parse(JSON.stringify(originalTrack.geoJson));
            
            // Генерируем уникальное имя для клона
            let cloneName = originalTrack.name;
            const baseName = cloneName.replace(/ \(копия( \d+)?\)$/, '');
            let copyNumber = 1;
            
            // Проверяем, есть ли уже треки с таким именем
            const existingNames = tracks.map(t => t.name);
            while (existingNames.includes(cloneName)) {
                cloneName = `${baseName} (копия ${copyNumber})`;
                copyNumber++;
            }
            
            // Если это первая копия без номера, используем просто "(копия)"
            if (copyNumber === 1 && !originalTrack.name.includes('(копия')) {
                cloneName = `${baseName} (копия)`;
                if (existingNames.includes(cloneName)) {
                    cloneName = `${baseName} (копия ${copyNumber})`;
                }
            }
            
            // Создаем новый трек
            const clonedTrack = {
                name: cloneName,
                geoJson: clonedGeoJson
            };
            
            // Добавляем трек в массив
            tracks.push(clonedTrack);
            
            // Обновляем карту и таблицу
            updateMap(tracks.length - 1);
            
            // Сохраняем в sessionStorage
            saveToSessionStorage();
        }
        
        // Функция добавления случайного отклонения к точке (в метрах)
        function addRandomOffset(lat, lon, maxOffsetMeters) {
            const R = 6371000; // Радиус Земли в метрах
            
            // Случайное расстояние отклонения (0 до maxOffsetMeters)
            const distance = Math.random() * maxOffsetMeters;
            
            // Случайный азимут (0-360 градусов)
            const bearing = Math.random() * 360 * Math.PI / 180;
            
            // Преобразуем в радианы
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;
            
            // Вычисляем новую точку
            const angularDistance = distance / R;
            const newLatRad = Math.asin(
                Math.sin(latRad) * Math.cos(angularDistance) +
                Math.cos(latRad) * Math.sin(angularDistance) * Math.cos(bearing)
            );
            const newLonRad = lonRad + Math.atan2(
                Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(latRad),
                Math.cos(angularDistance) - Math.sin(latRad) * Math.sin(newLatRad)
            );
            
            return [
                newLatRad * 180 / Math.PI,
                newLonRad * 180 / Math.PI
            ];
        }
        
        // Функция интерполяции точки на сегменте на заданном расстоянии
        function interpolatePointOnSegment(lat1, lon1, lat2, lon2, distanceFromStart) {
            const totalDistance = calculateDistance(lat1, lon1, lat2, lon2);
            
            if (totalDistance === 0) {
                return [lat1, lon1];
            }
            
            // Нормализуем расстояние (0-1)
            const t = Math.min(1, Math.max(0, distanceFromStart / totalDistance));
            
            // Линейная интерполяция
            const lat = lat1 + (lat2 - lat1) * t;
            const lon = lon1 + (lon2 - lon1) * t;
            
            return [lat, lon];
        }
        
        // Функция генерации трека на основе существующего
        function generateTrackFromTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const originalTrack = tracks[trackIndex];
            if (!originalTrack || !originalTrack.geoJson || !originalTrack.geoJson.features) {
                return;
            }
            
            const originalFeatures = originalTrack.geoJson.features;
            
            if (originalFeatures.length === 0) {
                alert('Исходный трек пуст');
                return;
            }
            
            // Генерируем уникальное имя для нового трека
            let newName = originalTrack.name + ' (сгенерирован)';
            const baseName = newName;
            let copyNumber = 1;
            
            const existingNames = tracks.map(t => t.name);
            while (existingNames.includes(newName)) {
                newName = `${baseName} ${copyNumber}`;
                copyNumber++;
            }
            
            // Создаем новый GeoJSON с обработанными сегментами
            const newFeatures = [];
            
            originalFeatures.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const originalCoords = feature.geometry.coordinates;
                    
                    if (originalCoords.length < 2) {
                        return; // Пропускаем сегменты с менее чем 2 точками
                    }
                    
                    const newCoords = [];
                    
                    // Проходим по всем сегментам между точками
                    for (let i = 0; i < originalCoords.length - 1; i++) {
                        const [lon1, lat1] = originalCoords[i];
                        const [lon2, lat2] = originalCoords[i + 1];
                        
                        // Расстояние между точками в километрах
                        const segmentDistance = calculateDistance(lat1, lon1, lat2, lon2);
                        
                        // Добавляем первую точку сегмента (без отклонения)
                        if (i === 0) {
                            newCoords.push([lon1, lat1]);
                        }
                        
                        // Генерируем промежуточные точки с шагом 7-20 метров
                        let currentDistance = 0;
                        const stepMin = 0.007; // 7 метров в километрах
                        const stepMax = 0.025; // 20 метров в километрах
                        const maxOffsetMeters = 10; // Максимальное отклонение 10 метров
                        
                        while (currentDistance < segmentDistance) {
                            // Случайный шаг между 7 и 20 метрами
                            const step = stepMin + Math.random() * (stepMax - stepMin);
                            currentDistance += step;
                            
                            if (currentDistance >= segmentDistance) {
                                break;
                            }
                            
                            // Интерполируем точку на сегменте
                            const [interpLat, interpLon] = interpolatePointOnSegment(
                                lat1, lon1, lat2, lon2, currentDistance
                            );
                            
                            // Добавляем случайное отклонение (0-10 метров)
                            const [offsetLat, offsetLon] = addRandomOffset(interpLat, interpLon, maxOffsetMeters);
                            newCoords.push([offsetLon, offsetLat]);
                        }
                        
                        // Добавляем последнюю точку сегмента (без отклонения)
                        if (i === originalCoords.length - 2) {
                            newCoords.push([lon2, lat2]);
                        }
                    }
                    
                    // Создаем новый feature с новыми координатами
                    if (newCoords.length >= 2) {
                        newFeatures.push({
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: newCoords
                            },
                            properties: {}
                        });
                    }
                }
            });
            
            if (newFeatures.length === 0) {
                alert('Не удалось сгенерировать трек');
                return;
            }
            
            // Создаем новый трек
            const generatedTrack = {
                name: newName,
                geoJson: {
                    type: 'FeatureCollection',
                    features: newFeatures
                }
            };
            
            // Добавляем трек в массив
            tracks.push(generatedTrack);
            
            // Обновляем карту и таблицу
            updateMap(tracks.length - 1);
            
            // Сохраняем в sessionStorage
            saveToSessionStorage();
        }
        
        // Функция объединения сегментов трека в один
        function mergeTrackSegments(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson || !track.geoJson.features) {
                return;
            }
            
            const features = track.geoJson.features;

            if (features.length === 0) {
                return;
            }

            // Подсчитываем общее количество точек до объединения
            let totalPointsBefore = 0;
            features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    totalPointsBefore += feature.geometry.coordinates.length;
                }
            });

            // Отключаем редактирование, если трек в режиме редактирования
            if (editingTrackIndex === trackIndex) {
                updateTrackGeoJSON(trackIndex);
                disableTrackEditing(trackIndex);
            }

            // Объединяем все координаты, время и высоту
            const mergedCoordinates = [];
            const mergedCoordTimes = [];
            const mergedElevations = [];

            features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coords = feature.geometry.coordinates;
                    const coordTimes = feature.properties && feature.properties.coordTimes ?
                        feature.properties.coordTimes : [];
                    const elevations = feature.properties && feature.properties.elevations ?
                        feature.properties.elevations : [];

                    // Добавляем координаты с правильной обработкой дубликатов
                    coords.forEach((coord, index) => {
                        // Проверяем, является ли точка дубликатом предыдущей
                        const isDuplicate = mergedCoordinates.length > 0 &&
                            mergedCoordinates[mergedCoordinates.length - 1][0] === coord[0] &&
                            mergedCoordinates[mergedCoordinates.length - 1][1] === coord[1];

                        if (isDuplicate) {
                            // Пропускаем дублирующуюся точку
                            return;
                        }

                        // Добавляем координату
                        mergedCoordinates.push(coord);

                        // Добавляем время, если есть
                        if (index < coordTimes.length) {
                            mergedCoordTimes.push(coordTimes[index]);
                        }

                        // Добавляем высоту, если есть
                        if (index < elevations.length) {
                            mergedElevations.push(elevations[index]);
                        } else {
                            mergedElevations.push(null);
                        }
                    });
                }
            });
            
            // Создаем новый feature с объединенными данными
            const mergedProperties = {};
            const expectedPoints = mergedCoordinates.length;
            if (mergedCoordTimes.length > 0) {
                let times = [...mergedCoordTimes];
                if (times.length > expectedPoints) {
                    times = times.slice(0, expectedPoints);
                }
                while (times.length < expectedPoints) {
                    times.push(times.length > 0 ? times[times.length - 1] : new Date().toISOString());
                }
                mergedProperties.coordTimes = times;
            }
            if (mergedElevations.length > 0) {
                let elevations = [...mergedElevations];
                if (elevations.length > expectedPoints) {
                    elevations = elevations.slice(0, expectedPoints);
                }
                while (elevations.length < expectedPoints) {
                    elevations.push(null);
                }
                mergedProperties.elevations = elevations;
            }

            // Сохраняем другие свойства из первого feature
            if (features[0].properties) {
                Object.keys(features[0].properties).forEach(key => {
                    if (key !== 'coordTimes' && key !== 'elevations') {
                        mergedProperties[key] = features[0].properties[key];
                    }
                });
            }
            
            // Заменяем все features одним объединенным
            track.geoJson.features = [{
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: mergedCoordinates
                },
                properties: mergedProperties
            }];

            // Обновляем карту и таблицу
            updateMap(trackIndex);

            // Сохраняем в sessionStorage
            saveToSessionStorage();

            // Показываем результат
            const totalPointsAfter = mergedCoordinates.length;
            const removedPoints = totalPointsBefore - totalPointsAfter;
            const totalFeatures = features.length;

            let message = 'Объединение завершено.\n';
            if (totalFeatures > 1) {
                message += `Объединено features: ${totalFeatures} → 1\n`;
            }
            if (removedPoints > 0) {
                message += `Удалено дубликатов: ${removedPoints}\n`;
                message += `Точек: ${totalPointsBefore} → ${totalPointsAfter}`;
            } else {
                message += `Дубликаты не найдены. Точек: ${totalPointsAfter}`;
            }

            alert(message);
        }
        
        // Функция инверсии трека (реверс)
        function reverseTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return false;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson || !track.geoJson.features) {
                return false;
            }
            
            const features = track.geoJson.features;
            
            if (features.length === 0) {
                alert('Трек пуст');
                return false;
            }
            
            // Инвертируем каждый сегмент (feature)
            features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coordinates = feature.geometry.coordinates;
                    if (coordinates.length > 1) {
                        // Инвертируем порядок координат
                        feature.geometry.coordinates = coordinates.reverse();
                        
                        // Инвертируем время точек
                        if (feature.properties && feature.properties.coordTimes) {
                            feature.properties.coordTimes.reverse();
                        }
                        
                        // Инвертируем высоту точек
                        if (feature.properties && feature.properties.elevations) {
                            feature.properties.elevations.reverse();
                        }
                    }
                }
            });
            
            // Если несколько сегментов, инвертируем порядок самих сегментов
            if (features.length > 1) {
                features.reverse();
            }
            
            // Обновляем карту и таблицу
            updateMap(trackIndex);
            
            // Сохраняем в sessionStorage
            saveToSessionStorage();
        }
        
        // Функции для управления модальным окном статуса установки высот
        function showElevationStatusModal() {
            const modal = document.getElementById('elevation-status-modal-overlay');
            if (modal) {
                modal.classList.add('show');
            }
        }
        
        function hideElevationStatusModal() {
            const modal = document.getElementById('elevation-status-modal-overlay');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function updateElevationStatus(totalPoints, processedPoints, currentBatch, totalBatches, statusText, debugInfo) {
            const totalInfoEl = document.getElementById('elevation-total-info');
            const progressBarEl = document.getElementById('elevation-progress-bar');
            const progressTextEl = document.getElementById('elevation-progress-text');
            const currentStatusEl = document.getElementById('elevation-current-status');
            const debugInfoEl = document.getElementById('elevation-debug-info');
            
            if (totalInfoEl) {
                totalInfoEl.textContent = `Всего точек: ${totalPoints} | Батчей: ${totalBatches} | Размер батча: 100 точек`;
            }
            
            if (progressBarEl && progressTextEl) {
                const progress = totalPoints > 0 ? Math.round((processedPoints / totalPoints) * 100) : 0;
                progressBarEl.style.width = progress + '%';
                progressTextEl.textContent = `Обработано: ${processedPoints} / ${totalPoints} (${progress}%)`;
            }
            
            if (currentStatusEl) {
                currentStatusEl.textContent = statusText || 'Ожидание...';
            }
            
            if (debugInfoEl) {
                const debugLines = debugInfo || [];
                debugInfoEl.innerHTML = debugLines.map(line => {
                    const timestamp = new Date().toLocaleTimeString();
                    return `[${timestamp}] ${line}`;
                }).join('<br>');
                debugInfoEl.scrollTop = debugInfoEl.scrollHeight;
            }
        }
        
        // Функция установки высоты для всех точек трека
        async function setTrackElevations(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            if (elevationRequestInFlight) {
                alert('Другая установка высот уже выполняется. Дождитесь завершения.');
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson || !track.geoJson.features) {
                return;
            }
            
            // Если трек в режиме редактирования, сохраняем изменения из маркеров
            const wasEditing = editingTrackIndex === trackIndex;
            if (wasEditing) {
                updateTrackGeoJSON(trackIndex);
            }
            
            const features = track.geoJson.features;
            
            if (features.length === 0) {
                alert('Трек пуст');
                return;
            }
            
            // Собираем все координаты из всех сегментов
            const coordinates = [];
            features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    feature.geometry.coordinates.forEach(coord => {
                        coordinates.push({
                            latitude: coord[1],  // lat
                            longitude: coord[0]  // lon
                        });
                    });
                }
            });
            
            if (coordinates.length === 0) {
                alert('Трек не содержит координат');
                return;
            }
            
            elevationRequestInFlight = true;
            const controller = new AbortController();
            const { signal } = controller;
            
            // Показываем модальное окно статуса
            showElevationStatusModal();
            
            // Инициализация статуса
            const batchSize = 100;
            const totalPoints = coordinates.length;
            const startTime = Date.now();
            const debugInfo = [];
            
            // Скрываем кнопку закрытия во время работы
            const closeBtn = document.getElementById('elevation-status-close');
            const cancelBtn = document.getElementById('elevation-status-cancel');
            if (closeBtn) closeBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.style.display = 'inline-block';
            
            let cancelled = false;
            if (cancelBtn) {
                cancelBtn.onclick = () => {
                    cancelled = true;
                    controller.abort();
                    debugInfo.push('⚠️ Операция отменена пользователем');
                    updateElevationStatus(totalPoints, 0, 0, 0, 'Операция отменена', debugInfo);
                    if (closeBtn) closeBtn.style.display = 'inline-block';
                    if (cancelBtn) cancelBtn.style.display = 'none';
                };
            }
            
            // Собираем кэшированные значения и список запросов
            const allElevations = new Array(totalPoints);
            const pendingRequests = [];
            coordinates.forEach((coord, idx) => {
                const key = getElevationCacheKey(coord);
                if (elevationCache.has(key)) {
                    allElevations[idx] = elevationCache.get(key);
                } else {
                    pendingRequests.push({ coord, idx, key });
                }
            });
            
            const totalBatches = Math.ceil(pendingRequests.length / batchSize);
            let processedPoints = totalPoints - pendingRequests.length;
            
            updateElevationStatus(totalPoints, processedPoints, 0, totalBatches, 'Инициализация...', debugInfo);
            debugInfo.push(`🚀 Начало установки высот для ${totalPoints} точек`);
            if (pendingRequests.length > 0) {
                debugInfo.push(`📦 Будет отправлено ${totalBatches} батчей по ${batchSize} точек`);
            } else {
                debugInfo.push('📦 Все точки взяты из кэша, запросы не требуются');
            }
            
            const fetchOpenElevation = async (locations, attempt = 1) => {
                const MAX_ATTEMPTS = 3;
                const responseStart = Date.now();
                try {
                    const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ locations }),
                        signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    return { data, duration: Date.now() - responseStart };
                } catch (error) {
                    if (signal.aborted) {
                        throw new Error('Операция отменена пользователем');
                    }
                    if (attempt < MAX_ATTEMPTS) {
                        const delay = 500 * Math.pow(2, attempt - 1);
                        debugInfo.push(`🔁 Повтор запроса (попытка ${attempt + 1}) через ${delay}мс: ${error.message}`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return fetchOpenElevation(locations, attempt + 1);
                    }
                    throw error;
                }
            };
            
            const fetchOpenTopoData = async (locations) => {
                const query = locations.map(loc => `${loc.latitude},${loc.longitude}`).join('|');
                const url = `https://api.opentopodata.org/v1/aster30m?locations=${encodeURIComponent(query)}`;
                const response = await fetch(url);
                const data = await response.json();
                if (!response.ok || data.status !== 'OK' || !Array.isArray(data.results)) {
                    throw new Error(`OpenTopoData error: ${response.status} ${data.status || ''}`.trim());
                }
                return data;
            };
            
            const fetchOpenMeteo = async (loc) => {
                const url = `https://api.open-meteo.com/v1/elevation?latitude=${loc.latitude}&longitude=${loc.longitude}`;
                const response = await fetch(url);
                const data = await response.json();
                if (!response.ok || data.elevation === undefined || data.elevation === null) {
                    throw new Error(`OpenMeteo error: ${response.status}`);
                }
                const value = Array.isArray(data.elevation) ? data.elevation[0] : data.elevation;
                return Number.isFinite(value) ? value : null;
            };
            
            try {
                if (pendingRequests.length > 0) {
                    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                        if (cancelled) {
                            throw new Error('Операция отменена пользователем');
                        }
                        
                        const batchStart = batchIndex * batchSize;
                        const batchEnd = Math.min(batchStart + batchSize, pendingRequests.length);
                        const batchItems = pendingRequests.slice(batchStart, batchEnd);
                        const batchNumber = batchIndex + 1;
                        
                        const batchStartTime = Date.now();
                        updateElevationStatus(totalPoints, processedPoints, batchNumber, totalBatches, 
                            `Обработка батча ${batchNumber}/${totalBatches} (${batchItems.length} точек)...`, debugInfo);
                        debugInfo.push(`📤 Отправка батча ${batchNumber}/${totalBatches}: ${batchItems.length} точек`);
                        
                        const locations = batchItems.map(item => item.coord);
                        let { data, duration } = await fetchOpenElevation(locations);
                        
                        if (!data.results || data.results.length !== batchItems.length) {
                            throw new Error(`Неверный формат ответа от API (батч ${batchNumber}): получено ${data.results ? data.results.length : 0} результатов вместо ${batchItems.length}`);
                        }
                        
                        let minElevation = Infinity;
                        let maxElevation = -Infinity;
                        
                        // Если все высоты равны 0, пробуем альтернативный провайдер
                        const allZero = data.results.every(r => r.elevation === 0 || r.elevation === null || r.elevation === undefined);
                        if (allZero) {
                            let topoOk = false;
                            try {
                                debugInfo.push(`⚠️ OpenElevation вернул нули, пробуем OpenTopoData (ASTER30m) для батча ${batchNumber}`);
                                const fallbackData = await fetchOpenTopoData(locations);
                                if (fallbackData && Array.isArray(fallbackData.results) && fallbackData.results.length === batchItems.length) {
                                    data = { results: fallbackData.results.map(r => ({ elevation: r.elevation, latitude: r.location.lat, longitude: r.location.lng })) };
                                    duration = Date.now() - batchStartTime;
                                    topoOk = true;
                                } else {
                                    debugInfo.push('⚠️ OpenTopoData тоже не вернул данные, оставляем 0/null');
                                }
                            } catch (err) {
                                debugInfo.push(`⚠️ OpenTopoData ошибка: ${err.message}`);
                            }
                            
                            // Попробуем OpenMeteo поштучно, если все еще нули
                            if (!topoOk) {
                                debugInfo.push(`⚠️ Пробуем OpenMeteo для батча ${batchNumber}`);
                                for (let i = 0; i < batchItems.length; i++) {
                                    const item = batchItems[i];
                                    try {
                                        const elevation = await fetchOpenMeteo(item.coord);
                                        data.results[i].elevation = elevation;
                                    } catch (err) {
                                        debugInfo.push(`   • ${item.coord.latitude.toFixed(5)},${item.coord.longitude.toFixed(5)} OpenMeteo error: ${err.message}`);
                                    }
                                }
                            }
                        }
                    
                        data.results.forEach((result, idx) => {
                            const elevation = result.elevation;
                            const originalIndex = batchItems[idx].idx;
                            const key = batchItems[idx].key;
                            const elevNum = Number(elevation);
                            const hasElev = Number.isFinite(elevNum);
                            const stored = hasElev ? elevNum : null;
                            allElevations[originalIndex] = stored;
                            elevationCache.set(key, stored);
                            const lat = batchItems[idx].coord.latitude;
                            const lon = batchItems[idx].coord.longitude;
                            debugInfo.push(`      • ${lat.toFixed(5)},${lon.toFixed(5)} -> ${hasElev ? elevNum.toFixed(2) + 'м' : 'null'}`);
                            if (hasElev) {
                                minElevation = Math.min(minElevation, elevNum);
                                maxElevation = Math.max(maxElevation, elevNum);
                            }
                        });
                        
                        processedPoints += batchItems.length;
                        
                        debugInfo.push(`✅ Батч ${batchNumber}/${totalBatches} обработан за ${duration}мс`);
                        debugInfo.push(`   └─ Высоты: мин=${minElevation !== Infinity ? minElevation.toFixed(1) : 'N/A'}м, макс=${maxElevation !== -Infinity ? maxElevation.toFixed(1) : 'N/A'}м`);
                        
                        updateElevationStatus(totalPoints, processedPoints, batchNumber, totalBatches, 
                            `Батч ${batchNumber}/${totalBatches} обработан`, debugInfo);
                    }
                } else {
                    updateElevationStatus(totalPoints, processedPoints, 0, totalBatches, 'Все высоты взяты из кэша', debugInfo);
                }
                
                debugInfo.push(`🔄 Обновление GeoJSON данных...`);
                updateElevationStatus(totalPoints, processedPoints, totalBatches, totalBatches, 'Обновление данных...', debugInfo);
                
                // Обновляем высоты в GeoJSON
                let coordIndex = 0;
                features.forEach((feature, featureIndex) => {
                    if (feature.geometry && feature.geometry.type === 'LineString') {
                        if (!feature.properties) {
                            feature.properties = {};
                        }
                        
                        feature.properties.elevations = [];
                        
                        const coords = feature.geometry.coordinates;
                        coords.forEach((c, idx) => {
                            const elevation = allElevations[coordIndex];
                            const stored = elevation === undefined ? null : elevation;
                            feature.properties.elevations.push(stored);
                            
                            // Проставляем высоту и в сами координаты, чтобы экспорт без потерь
                            if (Array.isArray(c) && c.length >= 2) {
                                feature.geometry.coordinates[idx] = [c[0], c[1], stored];
                            }
                            
                            coordIndex++;
                        });
                    }
                });
                
                debugInfo.push(`✅ GeoJSON обновлен для ${features.length} сегментов`);
                
                // Обновляем карту и таблицу
                updateMap(trackIndex);
                
                // Сохраняем в sessionStorage
                saveToSessionStorage();
                
                // Если трек был в режиме редактирования, пересоздаем маркеры редактирования
                if (wasEditing && editingTrackIndex === trackIndex) {
                    // Маркеры уже были удалены при updateMap, нужно пересоздать
                    disableTrackEditing(trackIndex);
                    enableTrackEditing(trackIndex);
                }
                
                const totalTime = Date.now() - startTime;
                const avgTimePerPoint = totalPoints > 0 ? totalTime / totalPoints : 0;
                const avgTimePerBatch = totalBatches > 0 ? totalTime / totalBatches : 0;
                
                debugInfo.push(`🎉 Успешно завершено!`);
                debugInfo.push(`⏱️ Общее время: ${(totalTime / 1000).toFixed(2)}с`);
                debugInfo.push(`📊 Среднее время на точку: ${avgTimePerPoint.toFixed(2)}мс`);
                if (totalBatches > 0) {
                    debugInfo.push(`📊 Среднее время на батч: ${(avgTimePerBatch / 1000).toFixed(2)}с`);
                }
                
                updateElevationStatus(totalPoints, processedPoints, totalBatches, totalBatches, 
                    `✅ Высота установлена для ${totalPoints} точек за ${(totalTime / 1000).toFixed(2)}с`, debugInfo);
                
                // Показываем кнопку закрытия
                if (closeBtn) closeBtn.style.display = 'inline-block';
                if (cancelBtn) cancelBtn.style.display = 'none';
                
            } catch (error) {
                console.error('Ошибка при получении высот:', error);
                debugInfo.push(`❌ Ошибка: ${error.message}`);
                updateElevationStatus(totalPoints, processedPoints, 0, totalBatches, 
                    `❌ Ошибка: ${error.message}`, debugInfo);
                
                // Показываем кнопку закрытия
                if (closeBtn) closeBtn.style.display = 'inline-block';
                if (cancelBtn) cancelBtn.style.display = 'none';
                
                // Если трек был в режиме редактирования, пересоздаем маркеры редактирования даже при ошибке
                if (wasEditing && editingTrackIndex === trackIndex) {
                    disableTrackEditing(trackIndex);
                    enableTrackEditing(trackIndex);
                }
            } finally {
                elevationRequestInFlight = false;
                if (cancelBtn) {
                    cancelBtn.onclick = null;
                }
                controller.abort();
            }
        }
        
        // Функция установки времени начала трека
        function setTrackStartTime(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            const track = tracks[trackIndex];
            if (!track || !track.geoJson || !track.geoJson.features) {
                return;
            }
            
            // Если трек в режиме редактирования, сохраняем изменения из маркеров
            const wasEditing = editingTrackIndex === trackIndex;
            if (wasEditing) {
                updateTrackGeoJSON(trackIndex);
            }
            
            const features = track.geoJson.features;
            
            if (features.length === 0) {
                alert('Трек пуст');
                return;
            }
            
            // Подсчитываем общее количество точек
            let totalPoints = 0;
            features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    totalPoints += feature.geometry.coordinates.length;
                }
            });
            
            if (totalPoints < 2) {
                alert('Трек должен содержать минимум 2 точки');
                return;
            }
            
            // Запрашиваем дату и время начала
            const now = new Date();
            const defaultDateTime = now.toISOString().slice(0, 10) + ' ' + 
                String(now.getHours()).padStart(2, '0') + ':' + 
                String(now.getMinutes()).padStart(2, '0');
            
            const dateTimeInput = prompt(
                'Введите дату и время начала трека (формат: YYYY-MM-DD HH:mm):\n' +
                'Например: ' + defaultDateTime,
                defaultDateTime
            );
            
            if (!dateTimeInput || dateTimeInput.trim() === '') {
                return; // Пользователь отменил
            }
            
            // Парсим введенную дату и время
            let startTime;
            try {
                // Пробуем разные форматы
                const input = dateTimeInput.trim();
                if (input.includes('T')) {
                    // ISO формат
                    startTime = new Date(input);
                } else if (input.includes(' ')) {
                    // Формат YYYY-MM-DD HH:mm
                    const [datePart, timePart] = input.split(' ');
                    startTime = new Date(datePart + 'T' + timePart + ':00');
                } else {
                    startTime = new Date(input);
                }
                
                if (isNaN(startTime.getTime())) {
                    throw new Error('Неверный формат даты');
                }
            } catch (error) {
                alert('Ошибка: Неверный формат даты и времени. Используйте формат: YYYY-MM-DD HH:mm');
                return;
            }
            
            // Запрашиваем скорость для расчёта времени
            const speedInput = prompt(
                'Введите среднюю скорость (км/ч) для расчёта времени:',
                '5'
            );

            if (!speedInput || speedInput.trim() === '') {
                return; // Пользователь отменил
            }

            const averageSpeed = parseFloat(String(speedInput).replace(',', '.'));
            if (isNaN(averageSpeed) || averageSpeed <= 0) {
                alert('Скорость должна быть положительным числом');
                return;
            }
            
            // Устанавливаем время для каждой точки на основе заданной скорости
            let currentTime = new Date(startTime);
            let isFirstPoint = true;

            features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    if (!feature.properties) {
                        feature.properties = {};
                    }

                    const coords = feature.geometry.coordinates;
                    const coordTimes = [];

                    if (coords.length === 0) {
                        return;
                    }

                    for (let i = 0; i < coords.length; i++) {
                        if (isFirstPoint) {
                            // Первая точка всего трека - время начала
                            coordTimes.push(startTime.toISOString());
                            currentTime = new Date(startTime);
                            isFirstPoint = false;
                        } else {
                            // Остальные точки - рассчитываем время на основе расстояния и скорости
                            let prevCoord;
                            if (i === 0) {
                                // Первая точка в этом feature, берем последнюю точку предыдущего feature
                                const currentFeatureIndex = features.indexOf(feature);
                                if (currentFeatureIndex > 0) {
                                    const prevFeature = features[currentFeatureIndex - 1];
                                    const prevFeatureCoords = prevFeature?.geometry?.coordinates;
                                    if (prevFeatureCoords && prevFeatureCoords.length > 0) {
                                        prevCoord = prevFeatureCoords[prevFeatureCoords.length - 1];
                                    } else {
                                        prevCoord = coords[0];
                                    }
                                } else {
                                    prevCoord = coords[0];
                                }
                            } else {
                                prevCoord = coords[i - 1];
                            }

                            const [lon1, lat1] = prevCoord;
                            const [lon2, lat2] = coords[i];
                            const segmentDistance = calculateDistance(lat1, lon1, lat2, lon2);

                            // Вычисляем время для этого сегмента
                            const segmentTime = (segmentDistance / averageSpeed) * 3600 * 1000; // В миллисекундах

                            // Проверяем валидность currentTime перед добавлением
                            if (!currentTime || isNaN(currentTime.getTime())) {
                                console.error('Invalid currentTime detected, resetting to startTime');
                                currentTime = new Date(startTime);
                            }

                            // Добавляем время сегмента к текущему времени
                            const newTime = currentTime.getTime() + segmentTime;
                            if (isNaN(newTime)) {
                                console.error('Invalid time calculation:', {
                                    currentTime: currentTime.getTime(),
                                    segmentTime,
                                    segmentDistance,
                                    averageSpeed
                                });
                                currentTime = new Date(startTime);
                            } else {
                                currentTime = new Date(newTime);
                            }

                            coordTimes.push(currentTime.toISOString());
                        }
                    }

                    feature.properties.coordTimes = coordTimes;
                }
            });
            
            // Обновляем карту и таблицу
            updateMap(trackIndex);
            
            // Сохраняем в sessionStorage
            saveToSessionStorage();
            
            // Если трек был в режиме редактирования, пересоздаем маркеры редактирования
            if (wasEditing && editingTrackIndex === trackIndex) {
                // Маркеры уже были удалены при updateMap, нужно пересоздать
                disableTrackEditing(trackIndex);
                enableTrackEditing(trackIndex);
            }
            
            // Вычисляем общую длину трека и время
            let totalDistance = 0;
            features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'LineString') {
                    const coords = feature.geometry.coordinates;
                    for (let i = 0; i < coords.length - 1; i++) {
                        const [lon1, lat1] = coords[i];
                        const [lon2, lat2] = coords[i + 1];
                        totalDistance += calculateDistance(lat1, lon1, lat2, lon2);
                    }
                }
            });

            const lastFeature = features[features.length - 1];
            const lastCoordTimes = lastFeature.properties && lastFeature.properties.coordTimes ?
                lastFeature.properties.coordTimes : [];
            const lastTimeValue = lastCoordTimes.length > 0 ? new Date(lastCoordTimes[lastCoordTimes.length - 1]) : null;
            const totalTime = lastTimeValue && !isNaN(lastTimeValue.getTime()) ?
                (lastTimeValue - startTime) / 1000 / 3600 : 0;

            let statsMessage = `Время начала трека установлено: ${formatDateTimeWithTZ(startTime)}\n` +
                  `Общая длина: ${totalDistance.toFixed(2)} км\n` +
                  `Использованная скорость: ${averageSpeed.toFixed(2)} км/ч\n` +
                  `Часовой пояс: ${getBrowserTimeZone()} (${formatOffset(startTime)})`;

            if (totalTime > 0) {
                statsMessage += `\nОбщее время в пути: ${totalTime.toFixed(2)} ч`;
                statsMessage += `\nВремя конца: ${formatDateTimeWithTZ(lastTimeValue)}`;
            }

            alert(statsMessage);
        }
        
        // Функция удаления трека
        function deleteTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= tracks.length) {
                return;
            }
            
            // Отключение редактирования, если удаляемый трек был в режиме редактирования
            if (editingTrackIndex === trackIndex) {
                disableTrackEditing(trackIndex);
            }
            
            // Удаление слоев трека с карты
            const layers = trackLayers[trackIndex];
            if (layers) {
                layers.forEach(layer => {
                    map.removeLayer(layer);
                });
            }
            
            // Удаление маркеров начала и конца трека
            const startMarkers = trackStartMarkers[trackIndex];
            if (startMarkers) {
                startMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
            }
            
            const endMarkers = trackEndMarkers[trackIndex];
            if (endMarkers) {
                endMarkers.forEach(marker => {
                    map.removeLayer(marker);
                });
            }
            
            // Удаление трека из массивов
            tracks.splice(trackIndex, 1);
            trackLayers.splice(trackIndex, 1);
            trackStartMarkers.splice(trackIndex, 1);
            trackEndMarkers.splice(trackIndex, 1);
            trackVisibility.splice(trackIndex, 1);
            
            // Сброс выбранного трека, если он был удален
            if (selectedTrackIndex === trackIndex) {
                selectedTrackIndex = null;
            } else if (selectedTrackIndex > trackIndex) {
                // Корректировка индекса выбранного трека
                selectedTrackIndex--;
            }
            
            // Корректировка индекса редактируемого трека
            if (editingTrackIndex > trackIndex) {
                editingTrackIndex--;
            }
            
            // Обновление карты и таблицы
            if (tracks.length > 0) {
                // Пересчет границ для всех оставшихся треков
                const allLayers = trackLayers.flat();
                if (allLayers.length > 0) {
                    const group = new L.featureGroup(allLayers);
                    const bounds = group.getBounds();
                    sessionStorage.setItem('mapBounds', JSON.stringify({
                        north: bounds.getNorth(),
                        south: bounds.getSouth(),
                        east: bounds.getEast(),
                        west: bounds.getWest()
                    }));
                }
                saveToSessionStorage();
            } else {
                // Если треков не осталось, очищаем sessionStorage
                sessionStorage.removeItem('gpxTracks');
                sessionStorage.removeItem('mapBounds');
                sessionStorage.removeItem('trackVisibility');
            }
            
            // Обновление UI
            clearButton.disabled = tracks.length === 0;
            updateTracksTable();
        }
        
        // Функция сохранения состояния видимости в sessionStorage
        function saveTrackVisibility() {
            sessionStorage.setItem('trackVisibility', JSON.stringify(trackVisibility));
        }
        
        // Функция сохранения в sessionStorage
        function saveToSessionStorage() {
            const tracksData = tracks.map(track => ({
                name: track.name,
                geoJson: track.geoJson
            }));
            sessionStorage.setItem('gpxTracks', JSON.stringify(tracksData));
            saveTrackVisibility();
        }
        
        // Функция восстановления из sessionStorage
        function restoreFromSessionStorage() {
            try {
                const savedTracks = sessionStorage.getItem('gpxTracks');
                if (savedTracks) {
                    const tracksData = JSON.parse(savedTracks);
                    tracks = tracksData;
                    
                    // Восстановление состояния видимости
                    const savedVisibility = sessionStorage.getItem('trackVisibility');
                    if (savedVisibility) {
                        trackVisibility = JSON.parse(savedVisibility);
                        // Убеждаемся, что длина массива соответствует количеству треков
                        while (trackVisibility.length < tracks.length) {
                            trackVisibility.push(true);
                        }
                    } else {
                        // Если нет сохраненного состояния, инициализируем все как видимые
                        trackVisibility = new Array(tracks.length).fill(true);
                    }
                    
                    updateMap();
                    
                    // Восстановление границ карты
                    const savedBounds = sessionStorage.getItem('mapBounds');
                    if (savedBounds) {
                        const bounds = JSON.parse(savedBounds);
                        map.fitBounds([
                            [bounds.south, bounds.west],
                            [bounds.north, bounds.east]
                        ]);
                    }
                }
            } catch (error) {
                console.error('Ошибка восстановления из sessionStorage:', error);
            }
        }
        
        // Обработчик загрузки файлов
        fileInput.addEventListener('change', async function(e) {
            const files = Array.from(e.target.files);
            
            if (files.length === 0) return;
            
            const loadPromises = files.map(file => loadGPXFile(file));
            
            try {
                const results = await Promise.allSettled(loadPromises);
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        tracks.push(result.value);
                    } else {
                        alert(result.reason.message);
                    }
                });
                
                if (tracks.length > 0) {
                    updateMap();
                    saveToSessionStorage();
                }
            } catch (error) {
                alert('Ошибка загрузки файлов: ' + error.message);
            }
            
            // Сброс input для возможности повторной загрузки того же файла
            fileInput.value = '';
        });
        
        // Функция создания пустого трека
        function createEmptyTrack() {
            const trackName = prompt('Введите имя нового трека:', 'Новый трек');
            if (!trackName || trackName.trim() === '') {
                return;
            }
            
            const trimmedName = trackName.trim();
            
            // Проверяем, нет ли уже трека с таким именем
            const existingIndex = tracks.findIndex(track => track.name === trimmedName);
            if (existingIndex !== -1) {
                alert('Трек с таким именем уже существует');
                return;
            }
            
            // Создаем пустой трек
            const emptyTrack = {
                name: trimmedName,
                geoJson: {
                    type: 'FeatureCollection',
                    features: [{
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: []
                        },
                        properties: {}
                    }]
                }
            };
            
            // Добавляем трек
            tracks.push(emptyTrack);
            
            // Обновляем карту и таблицу
            updateMap(tracks.length - 1);
            
            // Сохраняем в sessionStorage
            saveToSessionStorage();
            
            // Автоматически включаем режим редактирования для нового трека
            const newTrackIndex = tracks.length - 1;
            enableTrackEditing(newTrackIndex);
            
            // Показываем модальное окно с подсказками
            showHelpModal();
        }
        
        // Функция показа модального окна с подсказками
        function showHelpModal() {
            try {
                // Проверяем, не отключил ли пользователь показ подсказок
                const dontShowAgain = localStorage.getItem('dontShowTrackHelp');
                if (dontShowAgain === 'true') {
                    return;
                }
                
                const modalOverlay = document.getElementById('help-modal-overlay');
                if (modalOverlay) {
                    modalOverlay.classList.add('show');
                }
            } catch (error) {
                console.error('Ошибка при показе модального окна:', error);
            }
        }
        
        // Функция скрытия модального окна
        function hideHelpModal() {
            try {
                const modalOverlay = document.getElementById('help-modal-overlay');
                if (modalOverlay) {
                    modalOverlay.classList.remove('show');
                }
                
                // Сохраняем настройку, если пользователь выбрал "Больше не показывать"
                const dontShowAgainCheckbox = document.getElementById('dont-show-again');
                if (dontShowAgainCheckbox && dontShowAgainCheckbox.checked) {
                    localStorage.setItem('dontShowTrackHelp', 'true');
                }
            } catch (error) {
                console.error('Ошибка при скрытии модального окна:', error);
            }
        }
        
        // Обработчик кнопки создания трека
        createTrackButton.addEventListener('click', function() {
            createEmptyTrack();
        });
        
        // Обработчик кнопки очистки
        clearButton.addEventListener('click', function() {
            // Проверка на активное редактирование
            if (editingTrackIndex !== null) {
                if (!confirm('Вы редактируете трек. Очистка завершит редактирование. Продолжить?')) {
                    return;
                }
                disableTrackEditing(editingTrackIndex);
            }
            
            if (!confirm('Очистить все треки?')) {
                return;
            }
            
            // Удаление всех слоев
            trackLayers.forEach(trackLayerGroup => {
                trackLayerGroup.forEach(layer => {
                    map.removeLayer(layer);
                });
            });
            trackLayers = [];
            
            // Удаление всех маркеров начала и конца
            trackStartMarkers.forEach(markerGroup => {
                markerGroup.forEach(marker => {
                    map.removeLayer(marker);
                });
            });
            trackStartMarkers = [];
            
            trackEndMarkers.forEach(markerGroup => {
                markerGroup.forEach(marker => {
                    map.removeLayer(marker);
                });
            });
            trackEndMarkers = [];
            
            tracks = [];
            trackVisibility = [];
            selectedTrackIndex = null;
            editingTrackIndex = null;
            
            // Очистка sessionStorage
            sessionStorage.removeItem('gpxTracks');
            sessionStorage.removeItem('mapBounds');
            sessionStorage.removeItem('trackVisibility');
            
            // Обновление UI
            clearButton.disabled = true;
            fileInput.value = '';
            updateTracksTable();
        });
        
        // Обработчики модального окна с подсказками
        // Используем делегирование событий для надежности
        // Обработчики событий для модального окна статуса установки высот
        document.addEventListener('click', function(e) {
            const closeBtn = document.getElementById('elevation-status-close');
            const modal = document.getElementById('elevation-status-modal-overlay');
            
            if (e.target && e.target.id === 'elevation-status-close') {
                hideElevationStatusModal();
            }
            
            if (modal && e.target === modal) {
                hideElevationStatusModal();
            }
        });
        
        document.addEventListener('click', function(e) {
            // Закрытие при клике на кнопку "Понятно"
            if (e.target && e.target.id === 'help-modal-ok') {
                e.preventDefault();
                e.stopPropagation();
                hideHelpModal();
            }
            
            // Закрытие при клике на overlay (но не на само модальное окно)
            const helpModalOverlay = document.getElementById('help-modal-overlay');
            if (helpModalOverlay && e.target === helpModalOverlay) {
                hideHelpModal();
            }
        });
        
        // Закрытие при нажатии Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const helpModalOverlay = document.getElementById('help-modal-overlay');
                if (helpModalOverlay && helpModalOverlay.classList.contains('show')) {
                    hideHelpModal();
                }
            }
        });
        
        // Восстановление состояния при загрузке страницы
        restoreFromSessionStorage();
    </script>
    
    <!-- Модальное окно статуса установки высот -->
    <div id="elevation-status-modal-overlay" class="modal-overlay">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">Установка высот точек</div>
            <div id="elevation-status-content" style="font-size: 14px; line-height: 1.6; color: #666; margin-bottom: 20px;">
                <div style="margin-bottom: 15px;">
                    <strong>Общая информация:</strong>
                    <div id="elevation-total-info" style="margin-top: 5px; color: #666;"></div>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>Прогресс:</strong>
                    <div style="margin-top: 5px;">
                        <div style="background: #f0f0f0; border-radius: 4px; height: 20px; position: relative; overflow: hidden;">
                            <div id="elevation-progress-bar" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="elevation-progress-text" style="margin-top: 5px; font-size: 12px; color: #666;"></div>
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>Текущий статус:</strong>
                    <div id="elevation-current-status" style="margin-top: 5px; color: #666;"></div>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>Отладочная информация:</strong>
                    <div id="elevation-debug-info" style="margin-top: 5px; font-family: monospace; font-size: 11px; color: #666; background: #f5f5f5; padding: 10px; border-radius: 4px; max-height: 200px; overflow-y: auto;"></div>
                </div>
            </div>
            <div style="margin-top: 20px; text-align: right;">
                <button class="modal-button" id="elevation-status-close" style="display: none;">Закрыть</button>
                <button class="modal-button primary" id="elevation-status-cancel" style="display: none;">Отмена</button>
            </div>
        </div>
    </div>
    
    <div id="help-modal-overlay" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">Как создать новый трек</div>
            <div class="modal-content">
                <p>Вы создали новый пустой трек. Чтобы нарисовать трек на карте:</p>
                <ul>
                    <li><strong>Кликните по карте</strong> - добавьте первую точку трека</li>
                    <li><strong>Продолжайте кликать</strong> - добавляйте новые точки для построения маршрута</li>
                    <li><strong>Перетаскивайте точки</strong> - в режиме редактирования можно перемещать точки, удерживая и перетаскивая их</li>
                    <li><strong>Удаляйте точки</strong> - кликните правой кнопкой мыши по точке и выберите "Удалить точку"</li>
                    <li><strong>Сохраните трек</strong> - нажмите "Сохранить" в контекстном меню трека, чтобы выйти из режима редактирования</li>
                </ul>
                <p style="margin-top: 15px; font-weight: 600; color: #007bff;">Совет: Трек автоматически переходит в режим редактирования после создания.</p>
            </div>
            <div class="modal-footer">
                <label class="modal-checkbox">
                    <input type="checkbox" id="dont-show-again">
                    <span>Больше не показывать</span>
                </label>
                <button class="modal-button primary" id="help-modal-ok">Понятно</button>
            </div>
        </div>
    </div>
</body>
</html>
